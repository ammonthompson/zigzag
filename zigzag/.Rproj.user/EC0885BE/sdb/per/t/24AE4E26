{
    "collab_server" : "",
    "contents" : "zigzag$methods(\n\n#' mcmc\n#' @name mcmc\n#' @description MCMC sampling from hieararchical bayesian mixture model\n#' @usage my_zigzag_object$mcmc(sample_frequency = 10, ngen = 10000, target_ESS = NULL,\n#' progress_plot = FALSE, write_to_files = TRUE, mcmcprefix = \"out\",\n#' compute_probs = TRUE, run_posterior_predictive = TRUE, append = FALSE)\n#' @param sample_frequency Number of generations between samples from the chain\n#' @param ngen Number of generations to run the chain\n#' @param target_ESS Run chain until the target effective sample size is achieved for the likelihood\n#' @param progress_plot Display a plot showing summary statistics and graphs. (in Rstudio)\n#' @param write_to_files Write posterior samples to output files located in mcmcprefix_mcmc_ouput directory\n#' @param mcmcprefix prefix for mcmc output directory as well as the output files within.\n#' @param compute_probs compute probabilities of activity for each gene. Default is TRUE.\n#' @param run_posterior_predictive run posterior predictive simulation for every other sample from the chain.\n#' @param append If posterior sample log files in mcmcprefix_mcmc_ouput already exists, then append samples to those files. Default is FALSE.\n#'\n#' @return blorb\n#' @export\n#'\n#' @examples{\n#' \\dontrun{mcmc(sample_frequency = 100, ngen = 50000, mcmcprefix = \"organ_x_posterior_sample\")}\n#' }\n#'\n  mcmc = function(sample_frequency = 10, ngen = 10000, target_ESS = NULL, progress_plot = FALSE,\n                  write_to_files = TRUE, mcmcprefix = \"out\", compute_probs = TRUE,\n                  run_posterior_predictive = TRUE, append = FALSE){\n\n    ###########################\n    # initialize output files #\n    ###########################\n    mcmc_prefixdir = paste0(mcmcprefix, \"_mcmc_output\")\n    vprefix = unlist(strsplit(mcmcprefix, split = \"/\"))\n    prefix = vprefix[length(vprefix)]\n\n\n    if(write_to_files & append == FALSE){\n\n      dir.create(paste0(output_directory, \"/\", mcmc_prefixdir))\n      .self$initializeOutputFiles(paste0(mcmc_prefixdir, \"/\", prefix), run_posterior_predictive)\n\n\n    }else if(append & !file.exists(paste0(output_directory, \"/\", mcmc_prefixdir, \"/\", prefix, \"_model_parameters.log\"))){\n\n      print(\"No file exists to append. Creating new files\")\n      print(paste0(output_directory, \"/\", mcmc_prefixdir, \"/\", prefix, \"_model_parameters.log\"))\n      dir.create(paste0(output_directory, \"/\", mcmc_prefixdir))\n      .self$initializeOutputFiles(paste0(mcmc_prefixdir, \"/\", prefix), run_posterior_predictive)\n\n    }\n\n\n    #############################################\n    # Set up progress plotting on active device #\n    #############################################\n    if(progress_plot){\n\n      if(length(dev.list()) == 0) dev.new()\n      progress_plot_device = dev.list()[1]\n\n      histogram_list = list()\n      histogram_list[[1]] <- hist(Yg, breaks = 100, plot = FALSE)\n\n      max_heights = max(histogram_list[[1]]$density[-1])\n      total_height = sum(max_heights) - 0.025\n      max_height = max(max_heights)\n\n      baselines = c(0)\n\n      plot(NULL, xlim=c(-10,10), ylim = c(0, 1.01 * total_height))\n      .self$drawLibraryHistograms(histogram_list[[1]]$mids, histogram_list[[1]]$density, bl = baselines[1])\n\n    }\n\n    #########################################################\n    # Begin posterior predictive density plot of            #\n    # Xg level 1 (lower level) and Yg level 2 (upper level) #\n    #########################################################\n    posXg_rowMeans = apply(Xg, 1, function(g) if(max(g) > -Inf) mean(g[g > -Inf]) else -Inf)\n    xg_colmeans = apply(Xg, 2, function(x) mean(x[x > -Inf]))\n    grandmean_xg_colmeans = mean(xg_colmeans)\n    scaled_xg = sapply(seq(num_libraries), function(lib) Xg[,lib] - xg_colmeans[lib] + grandmean_xg_colmeans)\n\n    num_libs_plot_postpred = num_libraries\n    if(num_libs_plot_postpred > 25) num_libs_plot_postpred = 25\n\n    plot_rows = sqrt(num_libs_plot_postpred) - sqrt(num_libs_plot_postpred)%%1 + (sqrt(num_libs_plot_postpred)%%1 > 0)\n    plot_cols = num_libs_plot_postpred/plot_rows - (num_libs_plot_postpred/plot_rows)%%1 + ((num_libs_plot_postpred/plot_rows)%%1 > 0)\n\n    multi_plot_pars = list()\n\n    if(run_posterior_predictive){\n\n      ## all libs up to 25 for lower level\n      pdf(file = paste0(output_directory, \"/\", mcmc_prefixdir, \"/\", prefix, \".scaled_L1_post_pred.pdf\"))\n\n      par(\"mfrow\" = c(plot_rows, plot_cols))\n\n      par(\"mai\" = c(0.4, 0.2, 0.2, 0.2))\n\n      for(plib in seq(num_libs_plot_postpred)){\n        libdensity = density(scaled_xg[, plib])\n        plot(libdensity$x, libdensity$y, type = \"l\", ylim = c(0, max(libdensity$y)*1.1),\n             lwd = 2, ylab = \"\", xlab = \"\", main = paste0(\"Lib. \", plib), axes = F)\n        axis(1)\n        multi_plot_pars[[plib]] = par(\"usr\",\"plt\",\"mfg\")\n      }\n\n      post_pred_multi_L1_plot_device = dev.cur()\n\n\n      ## Upper level plot\n      d_posXg_rowMeans = density(posXg_rowMeans)\n      d_posYg_rowMeans = density(Yg[out_spike_idx])\n\n      post_pred_plot_xlims = c(min(posXg_rowMeans[posXg_rowMeans > -Inf]) - 1, max(posXg_rowMeans) + 1)\n\n      pdf(file = paste0(output_directory, \"/\", mcmc_prefixdir, \"/\", prefix, \".L2_post_pred.pdf\"))\n\n      y_max =  max(c(d_posXg_rowMeans$y, d_posYg_rowMeans$y))\n\n      plot(NULL, xlim = post_pred_plot_xlims, main = \"Upper level\",\n           ylim = c(-1.2 * y_max, 1.2 * y_max),\n           xlab = \"log Expression\", ylab = \"density\")\n      abline(h=0, lwd = 2)\n\n      legend(post_pred_plot_xlims[1], 1.2 * y_max, legend = c(\"Post. Y\", \"Sim. Y\"),\n             col = c(\"orange\", \"green\"), lty = 1, lwd = 3)\n      legend(post_pred_plot_xlims[1],  -y_max, legend = c(\"Post.Y - Sim.Y\"),\n             col = c(\"red\"), lty = 1, lwd = 3)\n\n      post_pred_L2_plot_device = dev.cur()\n\n     }\n\n    if(progress_plot) dev.set(progress_plot_device)\n\n\n    ### Set up MCMC ###\n    all_allocation_mcmc = allocation_active_inactive * allocation_within_active[[1]]\n\n    allocation_trace <<- matrix(apply(component_matrix, 2, function(comp_matrix_col) 1 *\n                        (comp_matrix_col == all_allocation_mcmc)), nrow = num_transcripts)\n\n    lnl_trace[[length(lnl_trace) + 1]] <<- .self$calculate_lnl(num_libraries)\n\n    i <- gen\n    j <- 0\n\n    proposal_list <- list(.self$gibbsMixtureWeights,\n                          .self$gibbsAllocationActiveInactive,\n                          .self$gibbsAllocationWithinActive,\n                          .self$mhInactiveMeans,\n                          .self$mhInactiveVariances,\n                          .self$mhActiveMeansDif,\n                          .self$mhActiveVariances,\n                          .self$gibbsSpikeProb,\n                          .self$mhSpikeAllocation,\n                          .self$mhYg,\n                          .self$mhSigma_g,\n                          .self$mhTau,\n                          .self$mhSg,\n                          .self$mhS0Tau,\n                          .self$mhP_x )\n\n\n    plist_length <- length(proposal_list)\n\n    meanhistory = c()\n\n    ##############\n    # begin mcmc #\n    ##############\n\n    while(j <= ngen ){\n\n      ### run n = plist_length proposals ###\n      for(p in sample(seq(plist_length), plist_length, replace = TRUE, prob = proposal_probs)) proposal_list[[p]]()\n\n      #############################\n      # sample from markov chain  #\n      #############################\n      if(i %% sample_frequency == 0){\n\n        if(is.null(target_ESS)) j = i\n\n        cat(\"#### \",i,\" ####\", \"\\n\")\n\n        if(progress_plot) .self$drawLibraryDensities(histogram_list[[1]]$mids, 1, baselines[1], alpha = 0.05)\n\n        ### For computing Pr(zag = 1) ###\n        if(temperature == 1){\n\n          all_allocation_mcmc = allocation_active_inactive * allocation_within_active[[1]]\n          allocation_trace <<- allocation_trace + apply(component_matrix, 2, function(comp_matrix_col) 1 * (comp_matrix_col == all_allocation_mcmc))\n\n        }\n\n        lnl_trace[[length(lnl_trace) + 1]] <<- .self$calculate_lnl(num_libraries)\n\n\n        if(write_to_files & temperature == 1) .self$writeToOutputFiles(paste0(mcmc_prefixdir,\"/\", mcmcprefix), gen = i)\n\n        if(!is.null(target_ESS) & length(lnl_trace) > 100){\n\n          if(.self$calculate_lnl_ESS() > target_ESS) break\n\n        }\n\n        #######################################\n        # Run posterior predictive simulation #\n        #######################################\n        #add a red density line to the posterior predictive plot for simulated mean data|model params\n        if(run_posterior_predictive & (i / (2 * sample_frequency)) %% 1 == 0){\n\n          post_pred_instance = .self$posteriorPredictiveSimulation(prefix = mcmcprefix)\n\n          if((i / (2 * 2 * sample_frequency)) %% 1 == 0){\n            cat(\"plotting post pred...\\n\")\n\n            ### Multiple libs plots ###\n            dev.set(post_pred_multi_L1_plot_device)\n\n            lib_means_sim_xg = apply(post_pred_instance[[1]], 2, function(sx) mean(sx[sx > -Inf]))\n            grand_mean_sim_xg = mean(lib_means_sim_xg)\n            scaled_sim_xg = sapply(seq(num_libraries), function(sx) post_pred_instance[[1]][,sx] - lib_means_sim_xg[sx] + grand_mean_sim_xg)\n\n            for(lib_plot in seq(num_libs_plot_postpred)){\n              par(\"usr\" = multi_plot_pars[[lib_plot]]$usr)\n              par(\"plt\" = multi_plot_pars[[lib_plot]]$plt)\n              par(\"mfg\" = multi_plot_pars[[lib_plot]]$mfg)\n              lines(density(scaled_sim_xg[,lib_plot]), col = rgb(1,0,0,0.1))\n            }\n\n            ### Upper level plot ###\n            dev.set(post_pred_L2_plot_device)\n\n            ybins = seq(min(c(Yg[out_spike_idx] , post_pred_instance[[2]][out_spike_idx])) -1 ,\n                        max(c(Yg[out_spike_idx] , post_pred_instance[[2]][out_spike_idx]))+1, by = 0.2)\n\n            dYg = hist(Yg[out_spike_idx], plot = F, breaks = ybins)\n            dsimYg = hist(post_pred_instance[[2]][out_spike_idx], plot = F, breaks = ybins)\n\n            lines(lowess(dYg$mids, dYg$density - dsimYg$density - 0.6 * max(d_posXg_rowMeans$y), f=0.1) , col=rgb(1,0,0,0.05))\n            lines(density(Yg[out_spike_idx]), col = rgb(1,0.5,0,0.05))\n            lines(density(post_pred_instance[[2]][out_spike_idx]), col = rgb(0,0.85,0,0.05))\n\n            if(progress_plot) dev.set(progress_plot_device)\n\n          } #end posterior predicitve simulation\n\n        } #end posterior predictive processing\n\n      } #end sample from chain\n\n      i = i + 1\n\n      gen <<- i\n\n      on.exit(if(length(dev.list()) > 2) dev.off(post_pred_multi_L1_plot_device))\n      on.exit(if(length(dev.list()) > 2) dev.off(post_pred_L2_plot_device), add = TRUE)\n\n    } #end mcmc\n\n\n    ############################\n    # finalize post pred plots #\n    ############################\n    if(run_posterior_predictive){\n      #Level 1\n      dev.set(post_pred_multi_L1_plot_device)\n      for(i in seq(num_libs_plot_postpred)){\n        par(\"usr\" = multi_plot_pars[[i]]$usr)\n        par(\"plt\" = multi_plot_pars[[i]]$plt)\n        par(\"mfg\" = multi_plot_pars[[i]]$mfg)\n        lines(density(scaled_xg[,i]), lwd = 0.75)\n      }\n\n      #Upper level (2)\n      dev.set(post_pred_L2_plot_device)\n      abline(h= -0.6 * max(d_posXg_rowMeans$y), lwd = 1.5)\n\n\n      dev.off(post_pred_multi_L1_plot_device)\n      dev.off(post_pred_L2_plot_device)\n    }\n\n    #####################################\n    # compute gene activity state      ##\n    # probabilities and write to files ##\n    #####################################\n    if(compute_probs && write_to_files) .self$computeGeneExpressionProbs_writeToFile(paste0(mcmc_prefixdir,\"/\", prefix))\n\n    on.exit(if(length(dev.list()) > 2) dev.off(post_pred_multi_L1_plot_device))\n    on.exit(if(length(dev.list()) > 2) dev.off(post_pred_L2_plot_device), add = TRUE)\n\n  },\n\n\n\n  #######################################################\n  # Posterior predictive simulation to be called during #\n  # the mcmc when run_posterior_predictive == TRUE      #\n  #######################################################\n\n  posteriorPredictiveSimulation = function(num_sims = 1000, plotlib = 1, prefix = \"out\", recover_x = FALSE){\n\n    pp_prefix = paste0(output_directory, \"/\", prefix, \"_mcmc_output/\", prefix)\n\n    ##################\n    ### FUNCTIONS ####\n    ##################\n\n    #function pars\n    binwidth = 0.1\n    model_range = c(qnorm(0.000001, inactive_means, sqrt(inactive_variances)),\n                    qnorm(0.999999, active_means[num_active_components], sqrt(active_variances[num_active_components])))\n    Yg_range = c(min(Yg[out_spike_idx]), max(Yg[out_spike_idx]))\n    xg_greater_minusInf_idx = which(Xg > -Inf, arr.ind = T)\n    Xg_range = c(min(Xg[xg_greater_minusInf_idx]), max(Xg[xg_greater_minusInf_idx]))\n    all_ranges = c(model_range, Yg_range, Xg_range)\n\n    bins = seq(min(all_ranges) - 2, max(all_ranges) + 2, by = binwidth)\n    yg_lessThan_bin = sapply(bins, function(y) (Yg < y) * 1 )\n\n    get_cumulative = function(xdat){ #xdat is a vector (one library)\n\n      zeroIdx = which(xdat == -Inf)\n      num_zeros = length(zeroIdx)\n      p_zeros = num_zeros/num_transcripts\n\n      xdat = xdat[-zeroIdx]\n\n      F = c()\n      for( x in bins ) F = c( F, count( xdat <= x )/(num_transcripts - num_zeros))\n\n      return( c(p_zeros, F) )\n\n    }\n\n    get_rumsfeld = function(xdat, rec_x = FALSE){\n\n      model_Br = sapply(seq(num_libraries), function(r) (1 - spike_probability * (1 - weight_active)) * mean(1 - p_x[out_spike_idx, r]) +\n                          spike_probability * (1 - weight_active))\n\n      xdat_Br = sapply(seq(num_libraries), function(r) sum(xdat[,r] == -Inf)/num_transcripts)\n\n      if(rec_x == T) recover()\n\n      return(mean(abs(xdat_Br - model_Br)))\n\n    }\n\n    get_level1_wasserstein = function(xdat, rec_x = FALSE){\n\n      model_cum = sapply(seq(num_libraries), function(r){\n        colMeans(p_x[out_spike_idx, r] * yg_lessThan_bin[out_spike_idx, ])\n      })\n\n\n      norm_factor = colMaxs(model_cum)\n\n      model_cum = t(t(model_cum)/norm_factor)\n\n      xdat_cum = sapply(seq(num_libraries), function(r){\n        sapply(bins, function(y) mean(xdat[xdat[,r] > -Inf, r] < y))\n      })\n\n      #average number of genes detected < x averaged over all libraries and the wasserstein distance.\n      mean_xdat_cum = rowMeans(xdat_cum)\n      mean_model_cum = rowMeans(model_cum)\n      Wass_means = trapz_integration(bins, abs(mean_xdat_cum - mean_model_cum))\n\n      if(rec_x == T) recover()\n\n      return(c(Wass_means))\n\n    }\n\n    get_level2_wasserstein = function(ydat, rec_x = FALSE){\n\n      model_cum = get_model_cumulative(bins)\n      ydat_cum = sapply(bins[-1], function(x) mean(ydat[out_spike_idx] < x))\n\n      Wass_means = trapz_integration(bins[-1], abs(ydat_cum - model_cum))\n\n      if(rec_x == T) recover()\n\n      return(Wass_means)\n\n    }\n\n\n    #####################\n    ### END FUNCTIONS ###\n    #####################\n\n\n    #### Simulate data from posterior and compute realized discrepancy statstics\n\n    sim_xg = sapply(1:num_libraries, function(x){return(rnorm(length(Yg), Yg, sqrt(sigma_g)))})\n\n    # p detect\n    sim_xg = sapply(1:num_libraries, function(lib){\n\n      temp_sim_xg = sim_xg[,lib]\n      not_detected = (runif(length(Yg)) < (1 - p_x[,lib]))\n      temp_sim_xg[not_detected] <- -Inf\n\n      return(temp_sim_xg)\n\n    })\n\n    ### simulate spike p( spike | inactive )\n    sim_xg[in_spike_idx,] = rep(-Inf, num_libraries)\n\n    sim_xg = as.data.frame(sim_xg)\n\n    # level 1 discrepencies, zeros and non-zero Xg distros\n    W_L1 = get_level1_wasserstein(Xg) - get_level1_wasserstein(sim_xg)\n    B_rumsfeld = get_rumsfeld(Xg) - get_rumsfeld(sim_xg)\n\n\n    ### level 2 discrepency simulating Yg\n    #simulate Yg\n    sim_yg = NULL\n    sim_yg[inactive_idx] = rnorm(length(inactive_idx), inactive_means, sqrt(inactive_variances))\n    sim_yg[active_idx] = rnorm(length(active_idx), active_means[allocation_within_active[[1]][active_idx]],\n                               sqrt(active_variances[allocation_within_active[[1]][active_idx]]))\n\n\n    W_L2 = get_level2_wasserstein(Yg) - get_level2_wasserstein(sim_yg)\n\n    cat(\"W_L1: \",W_L1, \"  W_L2: \", W_L2, '\\n')\n\n    if(recover_x) recover()\n\n    write.table(matrix(c(gen, W_L1, W_L2, B_rumsfeld), nrow = 1),\n                file = paste0(pp_prefix, \".post_predictive_output.log\"),\n                append=T, sep=\"\\t\", row.names=F, col.names=F)\n\n    return(list(sim_xg, sim_yg))\n\n  }\n\n\n)\n",
    "created" : 1561484420297.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "27|67|297|2|\n306|108|444|2|\n",
    "hash" : "653043712",
    "id" : "24AE4E26",
    "lastKnownWriteTime" : 1562956080,
    "last_content_update" : 1562956080243,
    "path" : "C:/Users/ammon_work/Desktop/git_repos/normal_mixture/zigzag/R/zigzagMCMC.R",
    "project_path" : "R/zigzagMCMC.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}