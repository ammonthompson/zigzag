{
    "collab_server" : "",
    "contents" : "zigzag$methods(\n\n#' burnin\n#' @name burnin\n#' @description Run burnin and tune proposal size parameters for hieararchical bayesian mixture model\n#' @usage burnin(sample_frequency = 10, ngen = 1000, burnin_target_acceptance_rate=0.23,\n#' threads = 1, target_ESS = NULL, progress_plot = FALSE, write_to_files = TRUE,\n#' burninprefix = \"burnin\", append = FALSE)\n#' @param sample_frequency Number of generations between samples from the chain\n#' @param ngen Number of generations to run the chain\n#' @param burnin_target_acceptance_rate proportion of proposals that are accepted. For proposal size tuning.\n#' @param threads Depricated\n#' @param target_ESS Depricated. Probably\n#' @param progress_plot Show plots of model statistics as MCMC progresses\n#' @param write_to_files Write burnin samples to output files in burninprefix_burnin_output directory\n#' @param burninprefix The prefix for the burnin output directory as well as the burnin output files within\n#' @param append If files already exist from previous interrupted burnin, append to those files if TRUE.\n#'\n#' @return\n#' @export\n#'\n#' @examples\n  burnin = function(sample_frequency = 10, ngen = 1000, burnin_target_acceptance_rate=0.44,\n                 threads = 1, target_ESS = NULL, progress_plot = FALSE, write_to_files = TRUE,\n                 burninprefix = \"output\", append = FALSE){\n\n  timestart = as.numeric(Sys.time())\n\n  # initialize output files\n  mcmc_prefixdir = paste0(burninprefix, \"_burnin\")\n  vprefix = unlist(strsplit(burninprefix, split = \"/\"))\n  prefix = vprefix[length(vprefix)]\n\n  if(write_to_files & append == FALSE){\n\n   dir.create(paste0(output_directory, \"/\", mcmc_prefixdir))\n   .self$initializeOutputFiles(paste0(mcmc_prefixdir, \"/\", prefix))\n\n  }else if(append == TRUE & !file.exists(paste0(output_directory, \"/\", mcmc_prefixdir, \"/\", burninprefix, \"_burnin_model_parameters.log\"))){\n\n   print(\"File does not exist to append. Creating new file\")\n   dir.create(paste0(output_directory, \"/\", mcmc_prefixdir))\n   .self$initializeOutputFiles(paste0(mcmc_prefixdir, \"/\", prefix))\n\n  }\n\n\n  i = gen\n  j = 0\n\n\n  proposal_list <- list(.self$gibbsMixtureWeights, .self$gibbsAllocationActiveInactive, .self$gibbsAllocationWithinActive,\n                       .self$mhInactiveMeans, .self$mhInactiveVariances,\n                       .self$mhActiveMeansDif,\n                       .self$mhActiveVariances,\n                       .self$gibbsSpikeProb, .self$mhSpikeAllocation,\n                       .self$mhYg, .self$mhSigma_g,\n                       .self$mhTau, .self$mhSg, .self$mhS0Tau,\n                       .self$mhP_x)\n\n  plist_length <- length(proposal_list)\n\n  ################\n  # run the mcmc #\n  ################\n\n  # MCMC\n\n  while(j <= ngen ){\n   end = FALSE\n   for(p in sample(seq(plist_length), plist_length, replace = TRUE, prob = proposal_probs)){\n     proposal_list[[p]](tune = TRUE);\n\n     if(is.na(sum(Yg)) || is.na(sum(sigma_g)) ||is.na(sum(tuningParam_yg)) || is.na(sum(inactive_spike_allocation)) ||\n        is.nan(sum(inactive_spike_allocation)) || is.na(sum(allocation_active_inactive))||\n        is.nan(sum(allocation_active_inactive)) || is.na(sum(sigma_g_trace)) || is.na(sum(Yg_trace))){\n\n       print(\"an NA or NaN somewhere!\")\n       print(p)\n       end = TRUE\n       break\n\n     }\n   }\n   if(end) break\n\n\n   if(i %% sample_frequency == 0 & i > 2 * sample_frequency){\n\n     xx_timestart = as.numeric(Sys.time())\n\n     if(is.null(target_ESS)) j = i\n\n     cat(\"#### \",i,\" ####  \", lnl_trace[[length(lnl_trace)]], \"  prop. tscripts from inactive: \", round((sum(exp(Yg[inactive_idx])) - sum(exp(Yg[in_spike_idx])))/(10^6), 4),\n         \" inactive mean: \", round(inactive_means, 2), \"  active_means: \", round(active_means, 2),\"\\n\")\n\n     ##########################\n     ### Progress plot ########\n     ##########################\n\n     if(progress_plot){\n\n       #plot variance trend\n       plotdx = seq(-6,8,by=0.1)\n       plot(rowMeans(Xg),rowVars(Xg), xlim=c(-6,8), ylim=c(0,5),col=rgb(0,0,0,0.1))\n       polygon(c(plotdx, rev(plotdx)),\n               c(qlnorm(0.025, s0 + s1*plotdx + tau, sqrt(tau)), rev(qlnorm(0.975, s0 + s1*plotdx +tau, sqrt(tau)))),\n               col = rgb(1,0,0,0.2))\n       lines(plotdx, exp(s0 + s1*plotdx),lwd = 2, col=\"red\")\n\n       #plot prob detection curves\n       plot(seq(-10,10,by=0.1), .self$get_px(yy = seq(-10,10,by=0.1), gl = 1)[,1],type=\"l\",ylim=c(0,1), ylab = \"prob. detection\", xlab = \"log expression\", col=rgb(0,0,0,0.1))\n       sapply(1:num_libraries,function(x){lines(seq(-10,10,by=0.1), .self$get_px(yy = seq(-10,10,by=0.1), gl = 1)[,x])})\n\n       #plot(mean Xg, Yg relationship)\n       rawdat<-Xg; rawdat[rawdat == -Inf] <- -15\n       plot(rowMeans(rawdat)[allocation_active_inactive==0],Yg[allocation_active_inactive==0],ylab = \"Y\", xlab = \"log expression\", col=rgb(0,0,1,0.2), xlim=c(-15,12),ylim=c(-8,12))\n       points(rowMeans(rawdat)[allocation_active_inactive==1], Yg[allocation_active_inactive==1],col=rgb(1,0,0,0.2))\n       abline(0,1,col=\"red\")\n\n       #plot Yg mixture distribution\n       .self$plotHistoDensities(Yg)\n\n     }\n\n     #####################################################################\n     ## set trace vars (this doesn't store the values, just updates it. ##\n     ## Important in case user interrupts the burnin)                   ##\n     #####################################################################\n\n     s0_trace[[2]] <<- s0\n     s1_trace[[2]] <<- s1\n     alpha_r_trace[[2]] <<- alpha_r\n\n     inactive_means_trace[[2]] <<- inactive_means\n     inactive_variances_trace[[2]] <<- inactive_variances\n     spike_probability_trace[[2]] <<- spike_probability\n     active_means_trace[[2]] <<- active_means\n     active_variances_trace[[2]] <<- active_variances\n     weight_active_trace[[2]] <<- weight_active\n     weight_within_active_trace[[2]] <<- weight_within_active\n\n     if(temperature == 1){\n\n       all_allocation_burnin = allocation_active_inactive * allocation_within_active[[1]]\n\n       allocation_trace <<- matrix(apply(component_matrix, 2, function(comp_matrix_col) 1 *\n                                           (comp_matrix_col == all_allocation_burnin)), nrow = num_transcripts)\n\n     }\n\n     lnl_trace[[length(lnl_trace) + 1]] <<- .self$calculate_lnl(num_libraries)\n\n     if(write_to_files & temperature == 1) .self$writeToOutputFiles(paste0(mcmc_prefixdir,\"/\", prefix), gen = i)\n\n     if(!is.null(target_ESS)  & length(lnl_trace) > 100){\n       if(.self$calculate_lnl_ESS() > target_ESS){\n         break\n       }\n     }\n\n     cat(\"time: \", as.numeric(Sys.time()) - timestart, \"\\n\")\n     timestart = as.numeric(Sys.time())\n\n   }\n\n   i = i + 1\n\n   gen <<- i\n\n   ################################################\n   ### tune the tuning parameters (tuningParam) ###\n   ################################################\n\n   if( gen %% 400 == 0 ){\n\n     tuningParam_alpha_r <<- sapply(1:num_libraries, function(xtrace){\n       return(.self$x_tune(alpha_r_trace[[1]][[1]][xtrace,], tuningParam_alpha_r[xtrace], burnin_target_acceptance_rate, mintuningParam = 0.01, maxtuningParam = 2)\n       )})\n     tuningParam_s0 <<- .self$x_tune(s0_trace[[1]][[1]], tuningParam_s0, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 5)\n     tuningParam_s1 <<- .self$x_tune(s1_trace[[1]][[1]], tuningParam_s1, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 5)\n     tuningParam_tau <<- .self$x_tune(tau_trace[[1]][[1]], tuningParam_tau, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 5)\n     tuningParam_s0tau <<- .self$x_tune(s0tau_trace[[1]][[1]], tuningParam_s0tau, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 5)\n     tuningParam_sigma_g <<- .self$x_tune(sigma_g_trace, tuningParam_sigma_g, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 10)\n     tuningParam_yg <<- .self$x_tune(Yg_trace, tuningParam_yg, burnin_target_acceptance_rate, mintuningParam = 0.001, maxtuningParam = 10)\n\n     tuningParam_multi_sigma <<- .self$x_tune(multi_sigma_trace[[1]][[1]], tuningParam_multi_sigma, burnin_target_acceptance_rate, mintuningParam = 0.01, maxtuningParam = 10)\n     inactive_mean_tuningParam     <<- .self$x_tune(inactive_means_trace[[1]][[1]], inactive_mean_tuningParam, burnin_target_acceptance_rate, mintuningParam = 0.01, maxtuningParam = 10)\n     inactive_variance_tuningParam <<- .self$x_tune(inactive_variances_trace[[1]][[1]], inactive_variance_tuningParam, burnin_target_acceptance_rate,\n                                                    mintuningParam = 0.01, maxtuningParam = (inactive_variances_prior_log_max - inactive_variances_prior_log_min))\n\n     active_mean_tuningParam       <<- sapply(seq(num_active_components), function(lib){\n       return(.self$x_tune(active_means_trace[[1]][[1]][lib,], active_mean_tuningParam[lib], burnin_target_acceptance_rate, mintuningParam = 0.01, maxtuningParam = 10))})\n\n     if(shared_active_variances){\n\n       active_variance_tuningParam   <<- sapply(seq(num_active_components), function(lib){\n         return(.self$x_tune(active_variances_trace[[1]][[1]][1,], active_variance_tuningParam[1], burnin_target_acceptance_rate,\n                             mintuningParam = 0.01, maxtuningParam = (active_variances_prior_log_max - active_variances_prior_log_min)))})\n\n     }else{\n\n       active_variance_tuningParam   <<- sapply(seq(num_active_components), function(lib){\n         return(.self$x_tune(active_variances_trace[[1]][[1]][lib,], active_variance_tuningParam[lib], burnin_target_acceptance_rate,\n                             mintuningParam = 0.01, maxtuningParam = (active_variances_prior_log_max - active_variances_prior_log_min)))})\n\n     }\n\n     spike_probability_tuningParam <<- 1/.self$x_tune(spike_probability_trace[[1]][[1]], 1/spike_probability_tuningParam, burnin_target_acceptance_rate, maxtuningParam = 1/10, mintuningParam = 1/100000)\n     mixture_weight_tuningParam <<- 1/.self$x_tune(mixture_weight_trace[[1]][[1]], 1/mixture_weight_tuningParam, burnin_target_acceptance_rate, maxtuningParam = 1/10, mintuningParam = 1/1000000)\n\n   }\n\n  } #end mcmc\n\n  lnl_trace <<- list(lnl_trace[[length(lnl_trace)]])\n\n  }\n\n\n)\n",
    "created" : 1562185434360.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1504313962",
    "id" : "9FD5B362",
    "lastKnownWriteTime" : 1562714246,
    "last_content_update" : 1562714246729,
    "path" : "C:/Users/ammon_work/Desktop/git_repos/normal_mixture/zigzag/R/zigzagBurnin.R",
    "project_path" : "R/zigzagBurnin.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}