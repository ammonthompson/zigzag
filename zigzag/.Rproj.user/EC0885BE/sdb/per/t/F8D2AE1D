{
    "collab_server" : "",
    "contents" : "zigzag$methods(\n\n  ##########################\n  ### Lower level params ###\n  ##########################\n\n  mhSigma_g = function(recover_x = FALSE, tune = FALSE){\n\n    HR = 0\n\n    proposal <- .self$scale_move(sigma_g[out_spike_idx], tuningParam_sigma_g[out_spike_idx])\n\n    sigma_g_proposed <- proposal[[1]]\n\n    HR <- log(proposal[[2]])\n\n    proposed_XgLikelihood <- .self$computeXgLikelihood(Xg[out_spike_idx,], Yg[out_spike_idx], sigma_g_proposed, p_x[out_spike_idx,],\n                                                       spike_allocation = inactive_spike_allocation[out_spike_idx], nd_spike = no_detect_spike[out_spike_idx])\n\n    proposed_sigmaGProbability <- .self$computeSigmaGPriorProbability(sigma_g_proposed, Sg[out_spike_idx])\n\n    Lp_pp = proposed_XgLikelihood + proposed_sigmaGProbability\n\n    Lc_pp = XgLikelihood[out_spike_idx] + sigma_g_probability[out_spike_idx]\n\n    R = temperature * (Lp_pp - Lc_pp) + HR\n\n    if(recover_x) recover()\n\n    current_and_proposed <- cbind(sigma_g[out_spike_idx], sigma_g_proposed)\n\n    current_and_proposed_likelihood <- cbind(XgLikelihood[out_spike_idx], proposed_XgLikelihood)\n\n\n    num_choices <- length(out_spike_idx)\n\n    choice_idx <- (log(runif(num_choices)) < R) + 1  # 1 means reject proposal, 2 means accept proposal.\n\n    choice_matrix <- cbind(seq(num_choices), choice_idx) # row-column pairs for current_and_proposed_sigma_g_probability with 1st column meaning reject proposal\n\n    sigma_g[out_spike_idx] <<- current_and_proposed[choice_matrix]\n\n    if(tune){\n\n      if(length(out_spike_idx) < 2){\n\n        sigma_g_trace[out_spike_idx,] <<- cbind(matrix(sigma_g_trace[out_spike_idx,-1], nrow = length(out_spike_idx)), choice_idx - 1)\n\n      }else{\n\n        sigma_g_trace[out_spike_idx,] <<- cbind(sigma_g_trace[out_spike_idx,-1], choice_idx - 1)\n      }\n    }\n\n\n    XgLikelihood[out_spike_idx] <<- current_and_proposed_likelihood[choice_matrix]\n\n    current_and_proposed_sigma_g_probability <- cbind(sigma_g_probability[out_spike_idx], proposed_sigmaGProbability)\n\n    sigma_g_probability[out_spike_idx] <<- current_and_proposed_sigma_g_probability[choice_matrix]\n\n  },\n\n  mhSg = function(recover_x = FALSE, tune = FALSE){\n\n    HR = 0\n\n    selection = sample(seq(2), 1, prob = c(1,1))\n\n\n    if( selection == 1){\n\n      proposed_s0 <- s0 + rnorm(1, 0, tuningParam_s0)\n\n      proposed_s1 <- s1\n\n      if(tune) s0_trace[[1]][[1]] <<- c(s0_trace[[1]][[1]][-1], 0)\n\n    }else{\n\n      proposed_s0 <- s0\n\n      proposal <- .self$scale_move(s1, tuningParam_s1)\n\n      proposed_s1 <- proposal[[1]]\n\n      HR <- log(proposal[[2]])\n\n      if(tune) s1_trace[[1]][[1]] <<- c(s1_trace[[1]][[1]][-1], 0)\n\n    }\n\n    proposed_Sg <- .self$get_sigmax(ss0 = proposed_s0, ss1 = proposed_s1)\n\n    proposed_sigma_g_Likelihood <- .self$computeSigmaGPriorProbability(sigma_g[out_spike_idx], proposed_Sg[out_spike_idx])\n\n    Lp <- sum(proposed_sigma_g_Likelihood)\n\n    Lc <- sum(sigma_g_probability[out_spike_idx])\n\n    pp <- .self$computeS0PriorProbability(proposed_s0) + .self$computeS1PriorProbability(proposed_s1)\n\n    pc <- .self$computeS0PriorProbability(s0) + .self$computeS1PriorProbability(s1)\n\n    R <- temperature * (Lp - Lc + pp - pc) + HR\n\n    if(recover_x) recover()\n\n\n    if(log(runif(1)) < R){\n\n      s0 <<- proposed_s0\n      s1 <<- proposed_s1\n\n      if(selection == 1){\n\n        if(tune) s0_trace[[1]][[1]][100] <<- 1\n\n      }else {\n\n        if(tune) s1_trace[[1]][[1]][100] <<- 1\n\n      }\n\n      Sg <<- proposed_Sg\n\n      sigma_g_probability[out_spike_idx] <<- proposed_sigma_g_Likelihood\n\n    }\n\n  },\n\n  mhTau = function(recover_x = FALSE, tune = FALSE){\n\n    # proposed_tau <- abs(tau + rnorm(1, 0, tuningParam_tau))\n\n    proposal <- .self$scale_move(tau, tuningParam_tau)\n\n    proposed_tau <- proposal[[1]]\n\n    HR <- log(proposal[[2]])\n\n    proposed_tau_Likelihood <- .self$computeSigmaGPriorProbability(sigma_g[out_spike_idx], Sg[out_spike_idx], gtau = proposed_tau)\n\n    # tau_Likelihood <- .self$computeSigmaGPriorProbability(sigma_g[out_spike_idx], Sg[out_spike_idx], gtau = tau)\n\n    tau_Likelihood <- sigma_g_probability[out_spike_idx]\n\n    Lp <- sum(proposed_tau_Likelihood)\n    Lc <- sum(tau_Likelihood)\n\n    pp <- .self$computeTauPriorProbability(proposed_tau)\n    pc <- .self$computeTauPriorProbability(tau)\n\n    R <- temperature * (Lp - Lc + pp - pc) + HR\n\n    if(recover_x) recover()\n\n    if(tune) tau_trace[[1]][[1]] <<- c(tau_trace[[1]][[1]][-1], 0)\n\n    if(log(runif(1)) < R){\n\n      tau <<- proposed_tau\n\n      if(tune) tau_trace[[1]][[1]][100] <<- 1\n\n      sigma_g_probability[out_spike_idx] <<- proposed_tau_Likelihood\n\n    }\n\n\n  },\n\n  mhS0Tau = function(recover_x = FALSE, tune = FALSE){\n    HR = 0\n\n    proposal <- .self$scale_move(tau, tuningParam_s0tau)\n\n    proposed_s0 <- s0 - log(proposal[[2]])\n\n    proposed_tau <- proposal[[1]]\n\n    HR <- log(proposal[[2]])\n\n    if(tune) s0tau_trace[[1]][[1]] <<- c(s0tau_trace[[1]][[1]][-1], 0)\n\n    proposed_Sg <- .self$get_sigmax(ss0 = proposed_s0, ss1 = s1)\n\n    proposed_sigma_g_Likelihood <- .self$computeSigmaGPriorProbability(sigma_g[out_spike_idx], proposed_Sg[out_spike_idx], proposed_tau)\n\n    Lp <- sum(proposed_sigma_g_Likelihood)\n\n    Lc <- sum(sigma_g_probability[out_spike_idx])\n\n    pp <- .self$computeS0PriorProbability(proposed_s0) + .self$computeTauPriorProbability(proposed_tau)\n\n    pc <- .self$computeS0PriorProbability(s0) + .self$computeTauPriorProbability(tau)\n\n    R <- temperature * (Lp - Lc + pp - pc) + HR\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R){\n\n      s0 <<- proposed_s0\n\n      tau <<- proposed_tau\n\n      Sg <<- proposed_Sg\n\n      if(tune) s0tau_trace[[1]][[1]][100] <<- 1\n\n      sigma_g_probability[out_spike_idx] <<- proposed_sigma_g_Likelihood\n\n    }\n\n  },\n\n  mhP_x = function(recover_x = FALSE, tune = FALSE){\n\n    randlib=sample(num_libraries,1)\n\n    proposed_alpha_r <- alpha_r\n\n    proposal <- .self$scale_move(alpha_r[randlib], tuningParam_alpha_r[randlib])\n\n    proposed_alpha_r[randlib] <- proposal[[1]]\n\n    if(tune) alpha_r_trace[[1]][[1]][randlib,] <<- c(alpha_r_trace[[1]][[1]][randlib, -1], 0)\n\n    HR <- log(proposal[[2]])\n\n    proposed_p_x <- p_x\n\n    if(recover_x) recover()\n\n    proposed_p_x[,randlib] <- .self$get_px(falpha_r = proposed_alpha_r[randlib], yy = Yg)\n    # proposed_p_x[,randlib] <- .self$xxget_px(falpha_r = proposed_alpha_r[randlib], xx = Xg[,randlib])\n\n    if(num_libraries > 2){\n\n      proposed_xgLikelihood <- XgLikelihood + .self$computeXgLikelihood(Xg[,randlib], Yg, sigma_g, proposed_p_x[,randlib]) -\n        .self$computeXgLikelihood(Xg[,randlib], Yg, sigma_g, p_x[,randlib])\n\n    }else{\n\n      proposed_xgLikelihood <- .self$computeXgLikelihood(Xg, Yg, sigma_g, proposed_p_x)\n\n    }\n\n    Lp <- sum(proposed_xgLikelihood)\n\n    Lc <- sum(XgLikelihood)\n\n    pp <- .self$computeAlphaRPriorProbability(proposed_alpha_r)\n\n    pc <- .self$computeAlphaRPriorProbability(alpha_r)\n\n    R <- temperature * (Lp - Lc + pp - pc) + HR\n\n\n    if(log(runif(1)) < R & R != Inf){\n\n      alpha_r[randlib] <<- proposed_alpha_r[randlib]\n\n      p_x[,randlib] <<- proposed_p_x[,randlib]\n\n      if(tune) alpha_r_trace[[1]][[1]][randlib,100] <<- 1\n\n      XgLikelihood <<- proposed_xgLikelihood\n\n    }\n\n  },\n\n\n  ##############################\n  ### Upper level parameters ###\n  ##############################\n\n  mhYg = function(recover_x = FALSE, tune = FALSE){\n\n    Yg_proposed <<- Yg + rnorm(num_transcripts, 0, tuningParam_yg) * (1 - inactive_spike_allocation) #only change out of spike genes\n\n    Sg_proposed <- .self$get_sigmax(yy = Yg_proposed)\n\n    p_x_proposed <- .self$get_px(yy = Yg_proposed)\n\n    ## proposed Yg likelihoods\n    proposed_XgLikelihood = .self$computeXgLikelihood(Xg, Yg_proposed, sigma_g, p_x_proposed)\n\n    proposed_sigmaGProbability = .self$computeSigmaGPriorProbability(sigma_g, Sg_proposed)\n\n    Lp_pp = proposed_XgLikelihood\n\n    Lp_pp[inactive_idx] = Lp_pp[inactive_idx] +\n      .self$computeInactiveLikelihood(Yg_proposed[inactive_idx], spike_probability, inactive_means, inactive_variances, inactive_spike_allocation[inactive_idx])\n\n    Lp_pp[active_idx] = Lp_pp[active_idx] +\n      .self$computeActiveLikelihood(Yg_proposed[active_idx],  allocation_within_active[[1]][active_idx], active_means, active_variances)\n\n    Lp_pp = Lp_pp + proposed_sigmaGProbability\n\n\n    ## current Yg likelihoods\n    Lc_pc = XgLikelihood\n\n    Lc_pc[inactive_idx] = Lc_pc[inactive_idx] +\n      .self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability, inactive_means, inactive_variances, inactive_spike_allocation[inactive_idx])\n\n    Lc_pc[active_idx] = Lc_pc[active_idx] +\n      .self$computeActiveLikelihood(Yg[active_idx],  allocation_within_active[[1]][active_idx], active_means, active_variances)\n\n    Lc_pc = Lc_pc + sigma_g_probability\n\n    R = temperature * (Lp_pp - Lc_pc)\n\n    current_and_proposed <- cbind(Yg, Yg_proposed)\n\n    current_and_proposed_likelihood <- cbind(XgLikelihood, proposed_XgLikelihood)\n\n    if(recover_x) recover()\n\n    choice_idx <- 1 + (log(runif(num_transcripts)) < R)\n\n    choice_matrix <- cbind(seq(num_transcripts), choice_idx)\n\n    Yg <<- current_and_proposed[cbind(seq(num_transcripts), choice_idx)]\n\n    if(tune){\n\n      if(length(out_spike_idx) < 2){\n\n        Yg_trace[out_spike_idx,] <<- cbind(matrix(Yg_trace[out_spike_idx,-1], nrow = length(out_spike_idx)), choice_idx[out_spike_idx] - 1)\n\n      }else{\n\n        Yg_trace[out_spike_idx,] <<- cbind(Yg_trace[out_spike_idx,-1], choice_idx[out_spike_idx] - 1)\n      }\n    }\n\n    ## update XgLikelihood, Sg and p_x\n\n    XgLikelihood <<- current_and_proposed_likelihood[choice_matrix]\n\n    .self$set_sigmaX_pX()\n\n    current_and_proposed_sigmaGProbability <- cbind(sigma_g_probability, proposed_sigmaGProbability)\n\n    sigma_g_probability[out_spike_idx] <<- current_and_proposed_sigmaGProbability[choice_matrix][out_spike_idx]\n\n  },\n\n  gibbsMixtureWeights = function(recover_x = FALSE, tune = FALSE){\n    #Propose new weights for the vector: c(1 - omega^a, omega^a * c(omega^m_1/omega_a, omega^m_2, ...))\n\n    all_allocations = allocation_within_active[[1]] * allocation_active_inactive\n\n    num_in_components <- sapply(0:num_active_components, function(y){return(sum(all_allocations == y))}) * beta\n\n    new_weights <- r_dirichlet(c(weight_active_shape_2, weight_within_active_alpha) + num_in_components)\n\n    if(recover_x) recover()\n\n    if(! is.nan(new_weights[1])){\n\n      weight_active <<- 1 - new_weights[1]\n\n      weight_within_active <<- new_weights[-1]/sum(new_weights[-1]) #conditioned on omega^a (sum of the new_weights minus that of the inactive component)\n\n    }\n\n  },\n\n  gibbsAllocationActiveInactive = function(recover_x = FALSE, tune = FALSE) {\n\n    ### Gibbs move active/inactive component\n\n    L_0 = exp(.self$computeInactiveLikelihood(Yg, spike_probability, inactive_means, inactive_variances, inactive_spike_allocation, all = TRUE))\n\n    L_1 = 0\n\n    for(k in seq(num_active_components)){\n\n      L_1 = L_1 + weight_within_active[k] * exp(.self$computeActiveLikelihood(Yg, k, active_means, active_variances, all = TRUE))\n\n    }\n\n    prob_active <- weight_active * L_1 * (1-inactive_spike_allocation)/((1 - weight_active) * L_0 + weight_active * L_1 * (1-inactive_spike_allocation))\n\n    prob_active[is.nan(prob_active)] <- weight_active\n    allocation_active_inactive <<- rbinom(num_transcripts, 1, prob_active)\n\n    if(!is.null(active_gene_set)) allocation_active_inactive[active_gene_set_idx] <<- as.integer(1)\n\n    .self$setActiveInactive_idx()\n\n  },\n\n  gibbsAllocationWithinActive = function(recover_x = FALSE, tune = FALSE){\n\n    ln_smallL <- 0 #-400 #probably delete this\n\n    if(length(active_idx) > 0){\n\n      logL_k = NULL\n\n      if(length(active_idx) > 1){\n\n        for(k in seq(num_active_components)){\n\n          logL_k = cbind(logL_k, log(weight_within_active[k]) +\n                           .self$computeActiveLikelihood(Yg[active_idx], k, active_means, active_variances, all = TRUE) - ln_smallL)\n\n        }\n\n      }else{\n\n        for(k in seq(num_active_components)){\n\n          logL_k = c(logL_k, log(weight_within_active[k]) +\n                       .self$computeActiveLikelihood(Yg[active_idx], k, active_means, active_variances, all = TRUE) - ln_smallL)\n\n        }\n\n      }\n\n      if(is.vector(logL_k)) logL_k = matrix(logL_k, nrow=1, ncol=num_active_components)\n\n      if(recover_x) recover()\n\n      L_k = exp(logL_k)\n      # L_k[which(is.na(L_k), arr.ind=T)]=0\n\n      probs = L_k/rowSums(L_k)\n      cumprobs = rowCumsums(probs)\n      randsamp = floor(cumprobs/runif(nrow(probs)))\n      zeros = matrix(0, nrow(probs), num_active_components)\n      new_allocation <- rowSums(randsamp==zeros) + 1\n      newallo <- which(! is.na(new_allocation))\n      allocation_within_active[[1]][active_idx][newallo] <<- new_allocation[newallo]\n\n    }\n\n\n\n  },\n\n  mhInactiveMeans = function(recover_x = FALSE, tune = FALSE){\n    ### for each distribution parameter: propose and accept new value with MH algo\n\n    inactive_means_proposed <<- threshold_i - abs(threshold_i - inactive_means - rnorm(1, 0, inactive_mean_tuningParam[[1]]))\n\n    pp = .self$computeInactiveMeansPriorProbability(inactive_means_proposed)\n\n    pc = .self$computeInactiveMeansPriorProbability(inactive_means)\n\n    if(length(inactive_idx) > 0){\n\n      Lp = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability, inactive_means_proposed, inactive_variances,\n                                               inactive_spike_allocation[inactive_idx]))\n      Lc = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability, inactive_means, inactive_variances,\n                                               inactive_spike_allocation[inactive_idx]))\n\n    }else{\n\n      Lp = 0\n      Lc = 0\n\n    }\n\n    R = temperature * (Lp - Lc + pp - pc)\n\n\n    if(tune) inactive_means_trace[[1]][[1]] <<- c(inactive_means_trace[[1]][[1]][-1],0)\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R){\n\n      inactive_means <<- inactive_means_proposed\n\n      if(tune) inactive_means_trace[[1]][[1]][100] <<- 1\n\n    }\n\n  },\n\n  mhInactiveVariances = function(recover_x = FALSE, tune = FALSE){\n\n    inactive_variances_proposed <<- 10^(.self$two_boundary_slide_move(log(inactive_variances, 10), inactive_variances_prior_log_min,\n                                                                      inactive_variances_prior_log_max, inactive_variance_tuningParam))\n    if(tune) inactive_variances_trace[[1]][[1]] <<- c(inactive_variances_trace[[1]][[1]][-1], 0)\n\n    pp = .self$computeInactiveVariancesPriorProbability(inactive_variances_proposed)\n\n    pc = .self$computeInactiveVariancesPriorProbability(inactive_variances)\n\n    if(length(inactive_idx) > 0){\n\n      Lp = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability, inactive_means, inactive_variances_proposed,\n                                               inactive_spike_allocation[inactive_idx]))\n      Lc = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability, inactive_means, inactive_variances,\n                                               inactive_spike_allocation[inactive_idx]))\n\n    }else{\n\n      Lp = 0\n      Lc = 0\n\n    }\n\n    R =  temperature * (Lp - Lc + pp - pc)\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R){\n\n      inactive_variances <<- inactive_variances_proposed\n\n      if(tune) inactive_variances_trace[[1]][[1]][100] <<- 1\n\n    }\n\n  },\n\n  gibbsSpikeProb = function(recover_x = FALSE, tune = FALSE){\n\n    num_inspike = length(in_spike_idx)\n    num_outspike = length(inactive_idx) - num_inspike\n\n    new_spike_probability <- rbeta(1, num_inspike + spike_prior_shape_1, num_outspike + spike_prior_shape_2)\n\n    if(recover_x) recover()\n\n    if(! is.nan(new_spike_probability)){\n\n      spike_probability <<- new_spike_probability\n\n    }\n\n  },\n\n  mhSpikeAllocation = function(recover_x = FALSE, tune = FALSE){\n\n    # note, proposed moves are only within the inactive allocation,\n    # no moves between the spike and the active component are ever proposed\n\n    zero_and_inactive_idx = all_zero_idx[allocation_active_inactive[all_zero_idx] == 0] #this is to speed things up (will mess with simulating under prior)\n\n    inactive_spike_allocation_proposal = abs(inactive_spike_allocation[zero_and_inactive_idx] - 1)\n    proposed_out_spike_idx = which(inactive_spike_allocation_proposal==0)\n    proposed_in_spike_idx = which(inactive_spike_allocation_proposal==1)\n\n    current_out_spike_idx = which(inactive_spike_allocation[zero_and_inactive_idx]==0)\n    current_in_spike_idx = which(inactive_spike_allocation[zero_and_inactive_idx]==1)\n\n\n    #*** Make proposals. If in spike then propose out-of-spike inactive expression value. If out of spike propose into spike\n\n    yg_proposed = rnorm(length(zero_and_inactive_idx), inactive_means, sqrt(inactive_variances))\n\n    Sg_proposed <- .self$get_sigmax(yy = yg_proposed)\n\n    sigma_g_proposed <- rlnorm(length(zero_and_inactive_idx), log(Sg_proposed) + tau, sqrt(tau))  # P(sigma_g | proposed_Yg)\n\n    p_x_proposed <- .self$get_px(yy = yg_proposed, gl = gene_lengths[zero_and_inactive_idx])\n\n\n    #*** Compute prior probabilities\n\n    p_sigma_g_proposed <- .self$computeSigmaGPriorProbability(sigma_g_proposed, Sg_proposed)\n\n    p_sigma_g <- .self$computeSigmaGPriorProbability(sigma_g[zero_and_inactive_idx], Sg[zero_and_inactive_idx])\n\n    p_yg_proposed <- .self$computeInactiveLikelihood(Yg_proposed, spike_probability, inactive_means,\n                                                     inactive_variances, inactive_spike_allocation_proposal)\n\n    p_yg <- .self$computeInactiveLikelihood(Yg[zero_and_inactive_idx], spike_probability, inactive_means,\n                                            inactive_variances, inactive_spike_allocation[zero_and_inactive_idx])\n\n    pp = NULL; pc = NULL\n\n    ### this needs a clear explanation.\n    pp[c(proposed_out_spike_idx, proposed_in_spike_idx)] = c(p_yg_proposed[proposed_out_spike_idx] + p_sigma_g_proposed[proposed_out_spike_idx],\n                                                             rep(log(spike_probability), length(proposed_in_spike_idx)))\n\n    pc[c(current_in_spike_idx, current_out_spike_idx)] = c(rep(log(spike_probability), length(current_in_spike_idx)),\n                                                           p_yg[current_out_spike_idx] + p_sigma_g[current_out_spike_idx])\n\n\n\n    #*** Compute Likelihoods\n\n    Lp = .self$computeXgLikelihood(Xg[zero_and_inactive_idx,], yg_proposed, sigma_g_proposed, p_x_proposed,\n                                   inactive_spike_allocation_proposal, nd_spike = no_detect_spike[zero_and_inactive_idx])\n    Lc = XgLikelihood[zero_and_inactive_idx]\n\n    both_inf_boolean = ifelse(Lp == -Inf & Lc == -Inf, TRUE, FALSE)\n    Lp[both_inf_boolean] = 0\n    Lc[both_inf_boolean] = 0\n\n    #/// Compute Hastings Ratio\n\n    HR = NULL\n\n    # subtract out spike_probability because of use in computeInactiveLikelihood\n    HR[c(proposed_out_spike_idx, proposed_in_spike_idx)] = c(-(p_yg_proposed[proposed_out_spike_idx] - log(1-spike_probability) +\n                                                                 p_sigma_g_proposed[proposed_out_spike_idx]),\n                                                             p_yg[proposed_in_spike_idx] - log(1-spike_probability) +\n                                                               p_sigma_g[proposed_in_spike_idx])\n\n\n\n    #*** Update Parameters\n\n    R = temperature * (Lp - Lc + pp - pc) + HR\n\n    choice <- (log(runif(length(zero_and_inactive_idx))) < R) + 1\n\n    choice[which(is.na(choice) | is.nan(choice))] <- 1 #Do not update (set choice to current value) if NA or NaN.\n\n    choice_matrix <- cbind(seq(length(zero_and_inactive_idx)), choice)\n\n    current_proposed = cbind(inactive_spike_allocation[zero_and_inactive_idx], inactive_spike_allocation_proposal)\n\n    if(recover_x) recover()\n\n\n    inactive_spike_allocation[zero_and_inactive_idx] <<- current_proposed[choice_matrix]\n\n    yg_current_proposed = cbind(Yg[zero_and_inactive_idx], yg_proposed)\n\n    Yg[zero_and_inactive_idx][proposed_out_spike_idx] <<- yg_current_proposed[choice_matrix][proposed_out_spike_idx]\n\n    sigma_g_current_proposed <- cbind(sigma_g[zero_and_inactive_idx], sigma_g_proposed)\n\n    sigma_g[zero_and_inactive_idx][proposed_out_spike_idx] <<- sigma_g_current_proposed[choice_matrix][proposed_out_spike_idx]\n\n    .self$set_sigmaX_pX()\n\n    .self$setInSpike_idx()\n\n    xgl_current_proposed = cbind(Lc, Lp)\n\n    XgLikelihood[zero_and_inactive_idx] <<- xgl_current_proposed[choice_matrix]\n\n    sigma_gProb_current_proposed <- cbind(p_sigma_g, p_sigma_g_proposed)\n\n    sigma_g_probability[zero_and_inactive_idx][proposed_out_spike_idx] <<- sigma_gProb_current_proposed[choice_matrix][proposed_out_spike_idx]\n\n  },\n\n  mhActiveMeansDif = function(recover_x = FALSE, tune = FALSE){\n    # active means\n\n    if(length(active_idx) > 0){\n\n      sapply(sample(num_active_components, num_active_components, replace = TRUE), function(k){\n\n        active_means_dif_proposed <<- active_means_dif\n        active_means_dif_proposed[k] <<- abs(active_means_dif[k] + rnorm(1,0,active_mean_tuningParam[k]))\n\n        mp = .self$calculate_active_means(active_means_dif_proposed)\n        mc = active_means\n\n        Lp <- sum(.self$computeActiveLikelihood(Yg[active_idx], allocation_within_active[[1]][active_idx], mp, active_variances, inactive_spike_allocation[active_idx]))\n        Lc <- sum(.self$computeActiveLikelihood(Yg[active_idx], allocation_within_active[[1]][active_idx], mc, active_variances, inactive_spike_allocation[active_idx]))\n\n        pp = computeActiveMeansDifPriorProbability(active_means_dif_proposed[k])\n        pc = computeActiveMeansDifPriorProbability(active_means_dif[k])\n\n        R = temperature * (Lp + pp - Lc - pc)\n\n        if(recover_x) recover()\n\n\n        if(tune) active_means_trace[[1]][[1]][k,] <<- c(active_means_trace[[1]][[1]][k,-1],0)\n\n        if(log(runif(1)) < R){\n\n          active_means_dif[k] <<- active_means_dif_proposed[k]\n          if(tune) active_means_trace[[1]][[1]][k,100] <<- 1\n          active_means <<- .self$calculate_active_means(active_means_dif_proposed)\n\n        }\n\n      })\n\n    }else{\n\n\n      sapply(sample(num_active_components, num_active_components, replace = TRUE), function(k){\n\n        active_means_dif_proposed <<- active_means_dif\n        active_means_dif_proposed[k] <<- abs(active_means_dif[k] + rnorm(1,0,active_mean_tuningParam[k]))\n\n        pp = computeActiveMeansDifPriorProbability(active_means_dif_proposed[k])\n        pc = computeActiveMeansDifPriorProbability(active_means_dif[k])\n\n        R = temperature * (pp - pc)\n\n        if(recover_x) recover()\n\n        if(tune) active_means_trace[[1]][[1]][k,] <<- c(active_means_trace[[1]][[1]][k,-1],0)\n\n        if(log(runif(1)) < R){\n\n          active_means_dif[k] <<- active_means_dif_proposed[k]\n          if(tune) active_means_trace[[1]][[1]][k,100] <<- 1\n          active_means <<- .self$calculate_active_means(active_means_dif_proposed)\n\n        }\n\n      })\n\n    }\n\n  },\n\n  mhActiveVariances = function(recover_x = FALSE, tune = FALSE){\n\n    k = sample(num_active_components, num_active_components, replace = TRUE)\n\n    if(shared_active_variances){\n\n      active_variances_proposed <<- rep(10^(.self$two_boundary_slide_move(\n        log(active_variances[1], 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[1])),\n        num_active_components)\n\n      if(tune) active_variances_trace[[1]][[1]][1,] <<- c(active_variances_trace[[1]][[1]][1,-1],0)\n\n    }else{\n\n      active_variances_proposed[k] <<- 10^(.self$two_boundary_slide_move(log(active_variances[k], 10),\n                                                                         active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[k]))\n      if(tune) active_variances_trace[[1]][[1]][k,] <<- c(active_variances_trace[[1]][[1]][k,-1],0)\n\n    }\n\n    if(length(active_idx) > 0){\n\n      Lp = sum(.self$computeActiveLikelihood(Yg[active_idx], allocation_within_active[[1]][active_idx], active_means, active_variances_proposed, inactive_spike_allocation[active_idx]))\n      Lc = sum(.self$computeActiveLikelihood(Yg[active_idx], allocation_within_active[[1]][active_idx], active_means, active_variances, inactive_spike_allocation[active_idx]))\n\n    }else{\n\n      Lp = 0\n      Lc = 0\n\n    }\n\n    pp = .self$computeActiveVariancesPriorProbability(active_variances_proposed[k])\n    pc = .self$computeActiveVariancesPriorProbability(active_variances[k])\n\n    R = temperature * (Lp + pp - Lc - pc )\n\n    if(recover_x) recover()\n\n\n    if(log(runif(1)) < R){\n\n      if(shared_active_variances){\n\n        active_variances <<- rep(active_variances_proposed[1], num_active_components)\n\n        if(tune) active_variances_trace[[1]][[1]][1,100] <<- 1\n\n\n      }else{\n\n        active_variances[k] <<- active_variances_proposed[k]\n\n        if(tune) active_variances_trace[[1]][[1]][k,100] <<- 1\n\n      }\n\n    }\n\n  },\n\n\n\n\n  ################################################\n  # extra mcmc moves and moves Under Development #\n  ################################################\n\n  mhSpikeProb = function(recover_x = FALSE, tune = FALSE){\n    # inactive spike probs\n\n    if(length(inactive_idx) > 0){\n\n      # spike_probability_proposed <<- abs(spike_probability + rnorm(1, 0, spike_probability_tuningParam[[1]]))\n      # if(spike_probability_proposed > 1) spike_probability_proposed <<- 2 - spike_probability_proposed\n\n      proposal_scale <- spike_probability_tuningParam\n\n      spike_probability_proposed <<- rbeta(1, spike_probability * proposal_scale, (1 - spike_probability) * proposal_scale)\n\n      HR = dbeta(spike_probability, spike_probability_proposed * proposal_scale, (1 - spike_probability_proposed) * proposal_scale, log = TRUE) -\n        dbeta(spike_probability_proposed, spike_probability * proposal_scale, (1 - spike_probability) * proposal_scale, log = TRUE)\n\n      Lp = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability_proposed,\n                                               inactive_means, inactive_variances, inactive_spike_allocation[inactive_idx]))\n\n      pp = .self$computeSpikePriorProbability(spike_probability_proposed)\n\n      Lc = sum(.self$computeInactiveLikelihood(Yg[inactive_idx], spike_probability,\n                                               inactive_means, inactive_variances, inactive_spike_allocation[inactive_idx]))\n\n      pc = .self$computeSpikePriorProbability(spike_probability)\n\n      R = temperature * (Lp - Lc + pp - pc) + HR\n\n      if(recover_x) recover()\n\n      if(tune) spike_probability_trace[[1]][[1]] <<- c(spike_probability_trace[[1]][[1]][-1], 0)\n\n      if(log(runif(1)) < R){\n\n        spike_probability <<- spike_probability_proposed\n\n        if(tune) spike_probability_trace[[1]][[1]][100] <<- 1\n\n      }\n\n\n    }else{\n\n      # spike_probability_proposed <<- abs(spike_probability + rnorm(1, 0, spike_probability_tuningParam[[1]]))\n      # if(spike_probability_proposed > 1) spike_probability_proposed <<- 2 - spike_probability_proposed\n\n      proposal_scale <- spike_probability_tuningParam\n\n      spike_probability_proposed <<- rbeta(1, spike_probability * proposal_scale, (1 - spike_probability) * proposal_scale)\n\n      HR = dbeta(spike_probability, spike_probability_proposed * proposal_scale, (1 - spike_probability_proposed) * proposal_scale, log = TRUE) -\n        dbeta(spike_probability_proposed, spike_probability * proposal_scale, (1 - spike_probability) * proposal_scale, log = TRUE)\n\n      R = temperature * (.self$computeSpikePriorProbability(spike_probability_proposed) -\n                           .self$computeSpikePriorProbability(spike_probability)) + HR\n\n      if(recover_x) recover()\n\n      if(tune) spike_probability_trace[[1]][[1]] <<- c(spike_probability_trace[[1]][[1]][-1], 0)\n\n      if(log(runif(1)) < R){\n\n        spike_probability <<- spike_probability_proposed\n        if(tune) spike_probability_trace[[1]][[1]][100] <<- 1\n\n      }\n\n    }\n\n  },\n\n  mhCombinedMu = function(recover_x = FALSE, tune = FALSE){\n\n    if(recover_x) recover()\n\n    if(rbinom(1,1,0.5) == 0){\n\n      .self$mhInactiveMeans(recover_x, tune)\n\n    }else{\n\n      .self$mhActiveMeansDif(recover_x, tune)\n\n    }\n\n  },\n\n  mhCombinedSigma = function(recover_x = FALSE, tune = FALSE){\n\n\n    if(rbinom(1,1,0.5) == 0){\n\n      .self$mhInactiveVariances(recover_x, tune)\n\n    }else{\n\n      .self$mhActiveVariances(recover_x, tune)\n\n    }\n\n  },\n\n  mhCombinedMuAllocation = function(recover_x = FALSE, tune = FALSE){\n\n    # propose new component parameters\n    # propose/accept new allocations given the new parameters\n    # calculate R to accept/reject the new component params and new allocations\n\n    lib <- 1\n\n    active_means_dif_proposed <<- active_means_dif\n\n    inactive_means_proposed <<- inactive_means\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    # inspike <- which(inactive_spike_all == 1)\n\n    active_or_inactive = rbinom(1, 1, 1/(num_active_components + 1))\n\n    if(active_or_inactive == 1){\n\n      inactive_means_proposed <<- threshold_i - abs(threshold_i - inactive_means - rnorm(1, 0, inactive_mean_tuningParam[[1]]))\n\n      if(tune) inactive_means_trace[[1]][[lib]] <<- c(inactive_means_trace[[1]][[lib]][-1],0)\n\n      pp = computeInactiveMeansPriorProbability(inactive_means_proposed)\n      pc = computeInactiveMeansPriorProbability(inactive_means)\n\n\n    }else{\n\n      pk <- sample(seq(num_active_components), 1)\n\n      active_means_dif_proposed[pk] <<- abs(active_means_dif[pk] + rnorm(1,0,active_mean_tuningParam[pk]))\n\n      if(tune) active_means_trace[[1]][[lib]][pk,] <<- c(active_means_trace[[1]][[lib]][pk,-1],0)\n\n      pp = computeActiveMeansDifPriorProbability(active_means_dif_proposed)\n      pc = computeActiveMeansDifPriorProbability(active_means_dif)\n\n\n    }\n\n    # Lp = .self$computeInactiveLikelihood(Yg[not_inspike], spike_probability, inactive_means_proposed, inactive_variances,\n    #                                      inactive_spike_allocation[not_inspike], all = FALSE)\n    #\n    # Lc = .self$computeInactiveLikelihood(Yg[not_inspike], spike_probability, inactive_means, inactive_variances,\n    #                                      inactive_spike_allocation[not_inspike], all = FALSE)\n\n\n    Lp = (1 - spike_probability) *\n      1/(sqrt(inactive_variances) * sqrt2pi * exp((Yg[not_inspike] - inactive_means_proposed)^2/(2 * inactive_variances)))\n\n    Lc = (1 - spike_probability) *\n      1/(sqrt(inactive_variances) * sqrt2pi * exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances)))\n\n    if(!is.null(active_gene_set)){\n\n      actg_idx = which(gene_names[out_spike_idx] %in% active_gene_set)\n\n      Lp[actg_idx] = 0\n\n      Lc[actg_idx] = 0\n\n    }\n\n\n    mp = .self$calculate_active_means(active_means_dif_proposed)\n    mc = active_means\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - mp[k])^2/(2 * active_variances[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - mc[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log((1 - weight_active) * Lp + weight_active * Lpk))\n    lnLc <- beta_oneLib * sum(log((1 - weight_active) * Lc + weight_active * Lck))\n\n    R = temperature * (lnLp + pp - lnLc - pc)\n\n    if(recover_x) recover()\n\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      # print(\"#______________________________ OLD _________________________________#\")\n\n\n      if(active_or_inactive == 1){\n\n        inactive_means <<- inactive_means_proposed\n\n        if(tune) inactive_means_trace[[1]][[lib]][100] <<- 1\n\n      }else{\n\n        active_means_dif[pk] <<- active_means_dif_proposed[pk]\n\n        active_means <<- mp\n\n        if(tune) active_means_trace[[1]][[lib]][pk,100] <<- 1\n\n\n      }\n\n      .self$gibbsAllocationActiveInactive()\n      .self$gibbsAllocationWithinActive()\n\n    }\n\n  },\n\n  mhCombinedSigmaAllocation = function(recover_x = FALSE, tune = FALSE){\n\n    lib <- 1\n\n    inactive_variances_proposed <<- inactive_variances\n\n    active_variances_proposed <<- active_variances\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    active_or_inactive = rbinom(1,1,1/(num_active_components + 1))\n\n    #HR = 0\n\n    if(active_or_inactive == 1){\n\n      inactive_variances_proposed <<- 10^(.self$two_boundary_slide_move(\n        log(inactive_variances, 10), inactive_variances_prior_log_min, inactive_variances_prior_log_max, inactive_variance_tuningParam))\n\n      pp = computeInactiveVariancesPriorProbability(inactive_variances_proposed)\n\n      pc = computeInactiveVariancesPriorProbability(inactive_variances)\n\n      if(tune) inactive_variances_trace[[1]][[lib]] <<- c(inactive_variances_trace[[1]][[lib]][-1],0)\n\n      #HR = log(inactive_variances_proposed/inactive_variances)\n\n\n    }else{\n\n      if(shared_active_variances){\n\n        active_variances_proposed <<- rep(10^(.self$two_boundary_slide_move(\n          log(active_variances[1], 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[1])),\n          num_active_components)\n\n        pp = computeActiveVariancesPriorProbability(active_variances_proposed[1])\n\n        pc = computeActiveVariancesPriorProbability(active_variances[1])\n\n        if(tune) active_variances_trace[[1]][[lib]][1,] <<- c(active_variances_trace[[1]][[lib]][1,-1],0)\n\n        #HR = log(active_variances_proposed[1]/active_variances[1])\n\n\n      }else{\n\n        pk <- sample(seq(num_active_components), 1)\n\n        active_variances_proposed[pk] <<- 10^(.self$two_boundary_slide_move(\n          log(active_variances[pk], 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[pk]))\n\n        pp = computeActiveVariancesPriorProbability(active_variances_proposed)\n\n        pc = computeActiveVariancesPriorProbability(active_variances)\n\n        if(tune) active_variances_trace[[1]][[lib]][pk,] <<- c(active_variances_trace[[1]][[lib]][pk,-1],0)\n\n        #HR = log(active_variances_proposed[pk]/active_variances[pk])\n\n      }\n\n    }\n\n\n    Lp = (1 - spike_probability) * 1/(sqrt(inactive_variances_proposed) * sqrt2pi *\n                                        exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances_proposed)))\n\n    Lc = (1 - spike_probability) * 1/(sqrt(inactive_variances) * sqrt2pi *\n                                        exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances)))\n\n    if(!is.null(active_gene_set)){\n\n      actg_idx = which(gene_names[out_spike_idx] %in% active_gene_set)\n\n      Lp[actg_idx] = 0\n\n      Lc[actg_idx] = 0\n\n    }\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active[k] *\n          1/(sqrt(active_variances_proposed[k]) * sqrt2pi * exp((Yg[not_inspike] - active_means[k])^2/(2 * active_variances_proposed[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - active_means[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log((1 - weight_active) * Lp + weight_active * Lpk))\n    lnLc <- beta_oneLib * sum(log((1 - weight_active) * Lc + weight_active * Lck))\n\n    R = temperature * (lnLp + pp - lnLc - pc) #+ HR\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      # print(\"#______________________________ OLD _________________________________#\")\n\n      if(active_or_inactive == 1){\n\n        inactive_variances <<- inactive_variances_proposed\n\n        if(tune) inactive_variances_trace[[1]][[lib]][100] <<- 1\n\n      }else{\n\n        if(shared_active_variances){\n\n          active_variances <<- rep(active_variances_proposed[1], num_active_components)\n\n          if(tune) active_variances_trace[[1]][[lib]][1,100] <<- 1\n\n\n        }else{\n\n          active_variances[pk] <<- active_variances_proposed[pk]\n\n          if(tune) active_variances_trace[[1]][[lib]][pk,100] <<- 1\n\n        }\n\n\n      }\n\n      .self$gibbsAllocationActiveInactive()\n      .self$gibbsAllocationWithinActive()\n\n    }\n\n  },\n\n  mhMixtureWeights = function(recover_x = FALSE, tune = FALSE){\n    ## active genes are independently allocated to active subcomponents across libraries\n    dirichlet_proposal_scale <- mixture_weight_tuningParam\n\n    mixtureWeights <- c(1 - weight_active, weight_active * weight_within_active)\n    mixtureWeights_proposed <- r_dirichlet(mixtureWeights * dirichlet_proposal_scale)\n\n    if(0 %in% mixtureWeights_proposed) break\n\n    weight_active_proposed <<- 1 - mixtureWeights_proposed[1]\n    weight_within_active_proposed <<- mixtureWeights_proposed[-1]/sum(mixtureWeights_proposed[-1])\n\n    allweights_priorProbabilityProposed <- d_dirichlet(mixtureWeights_proposed, c(weight_active_shape_1, weight_within_active_alpha), log = TRUE)\n    allweights_priorProbability <- d_dirichlet(mixtureWeights, c(weight_active_shape_2, weight_within_active_alpha) , log = TRUE) #weight_active_shape_2 is for the inactive comp.\n\n    logHastings = d_dirichlet(mixtureWeights, mixtureWeights_proposed * dirichlet_proposal_scale , log = TRUE)  -\n      d_dirichlet(mixtureWeights_proposed, mixtureWeights * dirichlet_proposal_scale , log =TRUE)\n\n    logR = temperature * (.self$computeAllocationPriorProbability(c(1 - weight_active_proposed, weight_within_active_proposed)) + allweights_priorProbabilityProposed -\n                            .self$computeAllocationPriorProbability(c(1 - weight_active, weight_within_active)) - allweights_priorProbability) + logHastings\n\n\n    if(recover_x) recover()\n\n    if(tune) mixture_weight_trace[[1]][[1]] <<- c(mixture_weight_trace[[1]][[1]][-1],0)\n\n    if(log(runif(1)) < logR){\n\n      weight_active <<- weight_active_proposed\n      weight_within_active <<- weight_within_active_proposed\n\n      if(tune) mixture_weight_trace[[1]][[1]][100] <<- 1\n\n    }\n\n  },\n\n  mhCombinedSigmaMu = function(recover_x = FALSE){\n\n    lib = 1\n\n    active_means_dif_proposed <<- active_means_dif\n\n    inactive_means_proposed <<- inactive_means\n\n    inactive_variances_proposed <<- inactive_variances\n\n    active_variances_proposed <<- active_variances\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    random_mu <- sample(0:num_active_components, 1)\n\n    random_sigma <- sample(0:num_active_components, 1)\n\n    HR = 0\n\n\n    ### propose new mean\n\n    if(random_mu == 0){\n\n      inactive_means_proposed <<- threshold_i - abs(threshold_i - inactive_means - rnorm(1, 0, inactive_mean_tuningParam))\n\n      mu_pp = computeInactiveMeansPriorProbability(inactive_means_proposed)\n\n      mu_pc = computeInactiveMeansPriorProbability(inactive_means)\n\n    }else{\n\n      active_means_dif_proposed[random_mu] <<- abs(active_means_dif[random_mu] + rnorm(1, 0, active_mean_tuningParam[random_mu]))\n\n      mu_pp = computeActiveMeansDifPriorProbability(active_means_dif_proposed)\n\n      mu_pc = computeActiveMeansDifPriorProbability(active_means_dif)\n\n    }\n\n    ## propose new sigma\n\n    if(random_sigma == 0){\n\n      inactive_variances_proposed <<- 10^(.self$two_boundary_slide_move(log(inactive_variances, 10), inactive_variances_prior_log_min, inactive_variances_prior_log_max, inactive_variance_tuningParam))\n\n      sigma_pp = computeInactiveVariancesPriorProbability(inactive_variances_proposed)\n\n      sigma_pc = computeInactiveVariancesPriorProbability(inactive_variances)\n\n      HR = log(inactive_variances_proposed/inactive_variances)\n\n\n    }else{\n\n\n      active_variances_proposed[random_sigma] <<- 10^(.self$two_boundary_slide_move(log(active_variances[random_sigma], 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[random_sigma]))\n\n      sigma_pp = computeActiveVariancesPriorProbability(active_variances_proposed)\n\n      sigma_pc = computeActiveVariancesPriorProbability(active_variances)\n\n      HR = log(active_variances_proposed[random_sigma]/active_variances[random_sigma])\n\n\n    }\n\n\n    ## inactive component likelihood\n\n    Lp = (1 - weight_active) * (1 - spike_probability) *\n      1/(sqrt(inactive_variances_proposed) * sqrt2pi * exp((Yg[not_inspike] - inactive_means_proposed)^2/(2 * inactive_variances_proposed)))\n\n    Lc = (1 - weight_active) * (1 - spike_probability) *\n      1/(sqrt(inactive_variances) * sqrt2pi * exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances)))\n\n\n    ## active component likelihood\n\n    mp = .self$calculate_active_means(active_means_dif_proposed)\n    mc = active_means\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active[k] *\n          1/(sqrt(active_variances_proposed[k]) * sqrt2pi * exp((Yg[not_inspike] - mp[k])^2/(2 * active_variances_proposed[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - mc[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log(Lp + weight_active * Lpk))\n    lnLc <- beta_oneLib * sum(log(Lc + weight_active * Lck))\n\n    R = temperature * (lnLp + mu_pp + sigma_pp - lnLc - mu_pc - sigma_pc) + HR\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R){\n\n      # cat(\"*********SIIGMAA_____MUUUUUUU******\", random_mu, \"  \", random_sigma, \"\\n\")\n\n\n      if(random_mu == 0 && random_sigma == 0){\n\n\n        inactive_means <<- inactive_means_proposed\n\n\n        inactive_variances <<- inactive_variances_proposed\n\n\n      }else if(random_mu == 0 && random_sigma > 0){\n\n\n        inactive_means <<- inactive_means_proposed\n\n\n        active_variances[random_sigma] <<- active_variances_proposed[random_sigma]\n\n\n\n      }else if( random_mu > 0 && random_sigma == 0){\n\n\n        active_means_dif[random_mu] <<- active_means_dif_proposed[random_mu]\n\n        active_means <<- mp\n\n\n        inactive_variances <<- inactive_variances_proposed\n\n\n      }else{\n\n\n        active_means_dif[random_mu] <<- active_means_dif_proposed[random_mu]\n\n        active_means <<- mp\n\n\n        active_variances[random_sigma] <<- active_variances_proposed[random_sigma]\n\n      }\n\n      .self$gibbsAllocationActiveInactive()\n      .self$gibbsAllocationWithinActive()\n\n    }\n\n  },\n\n  mhSpikeAllocation_oneLibrary = function(recover_x = FALSE, tune = FALSE){\n\n    # note, proposed moves are only within the inactive allocation,\n    # no moves between the spike and the active component are ever proposed\n\n    zero_and_inactive_idx = all_zero_idx[which(allocation_active_inactive[all_zero_idx] == 0)]\n\n    inactive_spike_allocation_proposal = abs(inactive_spike_allocation[zero_and_inactive_idx] - 1)\n\n    proposed_out_spike_idx = which(inactive_spike_allocation_proposal==0)\n    proposed_in_spike_idx = which(inactive_spike_allocation_proposal==1)\n\n    current_out_spike_idx = which(inactive_spike_allocation[zero_and_inactive_idx]==0)\n    current_in_spike_idx = which(inactive_spike_allocation[zero_and_inactive_idx]==1)\n\n\n    #*** Make proposals\n\n    yg_proposed = rnorm(length(zero_and_inactive_idx), inactive_means, sqrt(inactive_variances))\n\n    p_x_proposed <- .self$get_px(yy = yg_proposed, gl = gene_lengths[zero_and_inactive_idx])\n    # p_x_proposed <- .self$xxget_px(yy = yg_proposed, gl = gene_lengths[zero_and_inactive_idx], xx = Xg[zero_and_inactive_idx,], sg = sigma_g[zero_and_inactive_idx])\n\n\n    #*** Compute likelihoods and prior probabilities\n\n    p_yg_proposed <- .self$computeInactiveLikelihood(yg_proposed, spike_probability, inactive_means, inactive_variances,\n                                                     inactive_spike_allocation_proposal)\n\n    p_yg <- .self$computeInactiveLikelihood(Yg[zero_and_inactive_idx], spike_probability, inactive_means, inactive_variances,\n                                            inactive_spike_allocation[zero_and_inactive_idx])\n\n\n    pp = NULL; pc = NULL\n\n    pp[c(proposed_out_spike_idx, proposed_in_spike_idx)] = c(p_yg_proposed[proposed_out_spike_idx] ,\n                                                             rep(log(spike_probability), length(proposed_in_spike_idx)))\n\n    pc[c(current_in_spike_idx, current_out_spike_idx)] = c(rep(log(spike_probability), length(current_in_spike_idx)),\n                                                           p_yg[current_out_spike_idx] )\n\n\n    #/// Compute Hastings Ratio\n\n    HR = NULL\n\n    HR[c(proposed_out_spike_idx, proposed_in_spike_idx)] = c(-(p_yg_proposed[proposed_out_spike_idx]  - log(1-spike_probability)),\n                                                             p_yg[proposed_in_spike_idx]  - log(1-spike_probability))\n\n\n\n    Lp <- .self$computeXgLikelihood_oneLibrary(Xg[zero_and_inactive_idx], p_x_proposed, spike_allocation = inactive_spike_allocation_proposal,\n                                               nd_spike = no_detect_spike[zero_and_inactive_idx])\n\n    Lc <- .self$computeXgLikelihood_oneLibrary(Xg[zero_and_inactive_idx], p_x[zero_and_inactive_idx], spike_allocation = inactive_spike_allocation[zero_and_inactive_idx],\n                                               nd_spike = no_detect_spike[zero_and_inactive_idx])\n\n\n\n    #*** Update Parameters\n\n    R = Lp + pp - Lc - pc + HR\n\n    choice <- (log(runif(length(zero_and_inactive_idx))) < R) + 1\n\n    choice_matrix <- cbind(seq(length(zero_and_inactive_idx)), choice)\n\n    current_proposed = cbind(inactive_spike_allocation[zero_and_inactive_idx], inactive_spike_allocation_proposal)\n\n    yg_current_proposed = cbind(Yg[zero_and_inactive_idx], yg_proposed)\n\n\n    if(recover_x) recover()\n\n\n    inactive_spike_allocation[zero_and_inactive_idx] <<- current_proposed[choice_matrix]\n\n    Yg[zero_and_inactive_idx][proposed_out_spike_idx] <<- yg_current_proposed[choice_matrix][proposed_out_spike_idx]\n\n    Yg[zero_and_inactive_idx][proposed_in_spike_idx] <<- yg_current_proposed[choice_matrix][proposed_in_spike_idx]\n\n    .self$set_sigmaX_pX()\n\n    .self$setInSpike_idx()\n\n\n  },\n\n  mhP_x_oneLibrary = function(recover_x = FALSE, tune = FALSE){\n\n    randlib=sample(num_libraries,1)\n\n    proposed_alpha_r <- alpha_r\n\n    proposal <- .self$scale_move(alpha_r[randlib], tuningParam_alpha_r[randlib])\n\n    proposed_alpha_r[randlib] <- proposal[[1]]\n\n    if(tune) alpha_r_trace[[1]][[1]][randlib,] <<- c(alpha_r_trace[[1]][[1]][randlib, -1], 0)\n\n    HR <- log(proposal[[2]])\n\n    proposed_p_x <- .self$get_px(falpha_r = proposed_alpha_r, yy = Yg)\n    # proposed_p_x <- .self$xxget_px(falpha_r = proposed_alpha_r, yy = Yg, xx = Xg[,randlib])\n\n    Lp <- sum(.self$computeXgLikelihood_oneLibrary(Xg, proposed_p_x))\n\n    Lc <- sum(.self$computeXgLikelihood_oneLibrary(Xg, p_x))\n\n    pp <- .self$computeAlphaRPriorProbability(proposed_alpha_r)\n\n    pc <- .self$computeAlphaRPriorProbability(alpha_r)\n\n    R <- Lp - Lc + pp - pc + HR\n\n    if(recover_x) recover()\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      alpha_r[randlib] <<- proposed_alpha_r[randlib]\n\n      p_x[,randlib] <<- proposed_p_x[,randlib]\n\n      if(tune) alpha_r_trace[[1]][[1]][randlib,100] <<- 1\n\n    }\n\n  },\n\n  mhYg_oneLibrary = function(recover_x = FALSE, tune = FALSE){\n\n    nodetect_inactive_idx <- which(allocation_active_inactive[all_zero_idx] == 0)\n\n    nodetect_active_idx <- which(allocation_active_inactive[all_zero_idx] == 1)\n\n    Yg_proposed <<- Yg[all_zero_idx] + rnorm(length(all_zero_idx), 0, tuningParam_yg[all_zero_idx]) * (1 - inactive_spike_allocation[all_zero_idx])\n\n    p_x_proposed <- .self$get_px(yy = Yg_proposed,  gl = gene_lengths[all_zero_idx])\n    # p_x_proposed <- .self$xxget_px(yy = Yg_proposed,  gl = gene_lengths[all_zero_idx], xx = Xg[all_zero_idx,], sg = sigma_g[all_zero_idx])\n\n    ## proposed Yg likelihoods\n    proposed_XgLikelihood = .self$computeXgLikelihood_oneLibrary(Xg[all_zero_idx], p_x_proposed, spike_allocation = inactive_spike_allocation[all_zero_idx],\n                                                                 spike_prob = spike_probability, nd_spike = no_detect_spike[all_zero_idx])\n\n    Lp_pp = proposed_XgLikelihood\n\n    Lp_pp[nodetect_inactive_idx] = Lp_pp[nodetect_inactive_idx] +\n      .self$computeInactiveLikelihood(Yg_proposed[nodetect_inactive_idx], spike_probability, inactive_means, inactive_variances, inactive_spike_allocation[all_zero_idx][nodetect_inactive_idx])\n\n    Lp_pp[nodetect_active_idx] = Lp_pp[nodetect_active_idx] +\n      .self$computeActiveLikelihood(Yg_proposed[nodetect_active_idx],  allocation_within_active[[1]][all_zero_idx][nodetect_active_idx], active_means, active_variances)\n\n\n    ## current Yg likelihoods\n    current_XgLikelihood <- .self$computeXgLikelihood_oneLibrary(Xg[all_zero_idx], p_x[all_zero_idx], spike_allocation = inactive_spike_allocation[all_zero_idx],\n                                                                 spike_prob = spike_probability, nd_spike = no_detect_spike[all_zero_idx])\n\n    Lc_pc <- current_XgLikelihood\n\n    Lc_pc[nodetect_inactive_idx] = Lc_pc[nodetect_inactive_idx] +\n      .self$computeInactiveLikelihood(Yg[all_zero_idx][nodetect_inactive_idx], spike_probability, inactive_means, inactive_variances, inactive_spike_allocation[all_zero_idx][nodetect_inactive_idx])\n\n    Lc_pc[nodetect_active_idx] = Lc_pc[nodetect_active_idx] +\n      .self$computeActiveLikelihood(Yg[all_zero_idx][nodetect_active_idx],  allocation_within_active[[1]][all_zero_idx][nodetect_active_idx], active_means, active_variances)\n\n    Lp_pp[which(is.na(Lp_pp))] <- -Inf\n\n    R = Lp_pp - Lc_pc\n\n    current_and_proposed <- cbind(Yg[all_zero_idx], Yg_proposed)\n\n    current_and_proposed_likelihood <- cbind(current_XgLikelihood, proposed_XgLikelihood)\n\n    if(recover_x) recover()\n\n    choice_idx <- 1 + (log(runif(length(Yg_proposed))) < R)\n\n    Yg[all_zero_idx] <<- current_and_proposed[cbind(seq(length(Yg_proposed)), choice_idx)]\n\n\n    ## update XgLikelihood, Sg and p_x\n\n    XgLikelihood[all_zero_idx] <<- current_and_proposed_likelihood[cbind(seq(length(Yg_proposed)), choice_idx)]\n\n    .self$set_sigmaX_pX()\n\n    if(tune) Yg_trace[all_zero_idx,] <<- cbind(Yg_trace[all_zero_idx,-1], choice_idx - 1)\n\n  },\n\n  mhCombinedMultiSigma = function(sigma_test = FALSE, tune = FALSE){\n\n    inactive_variances_proposed <<- inactive_variances\n\n    active_variances_proposed <<- active_variances\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    HR = 0\n\n    random_components = sample(0:num_active_components, 2, replace = FALSE)\n\n    if(0 %in% random_components){\n\n      pk <- random_components[which(random_components != 0)]\n\n      if(rbinom(1, 1, 0.5) < 1){\n\n        proposal <- .self$twoSigma_slide_move(log(c(inactive_variances, active_variances_proposed[pk]), 10), inactive_variances_prior_log_min, inactive_variances_prior_log_max, inactive_variance_tuningParam)\n\n        inactive_variances_proposed <<- 10^proposal[1]\n\n        active_variances_proposed[pk] <<- 10^proposal[2]\n\n      }else{\n\n        proposal <- .self$twoSigma_slide_move(log(c(active_variances_proposed[pk], inactive_variances), 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[pk])\n\n        inactive_variances_proposed <<- 10^proposal[2]\n\n        active_variances_proposed[pk] <<- 10^proposal[1]\n\n      }\n\n      pp = computeInactiveVariancesPriorProbability(inactive_variances_proposed) + computeActiveVariancesPriorProbability(active_variances_proposed)\n\n      pc = computeInactiveVariancesPriorProbability(inactive_variances) + computeActiveVariancesPriorProbability(active_variances)\n\n    }else{\n\n      pk1 <- random_components[1]\n\n      pk2 <- random_components[2]\n\n      proposal <- .self$twoSigma_slide_move(log(active_variances_proposed[c(pk1, pk2)], 10), active_variances_prior_log_min, active_variances_prior_log_max, active_variance_tuningParam[pk1])\n\n      active_variances_proposed[pk1] <<- 10^proposal[1]\n\n      active_variances_proposed[pk2] <<- 10^proposal[2]\n\n      pp = computeActiveVariancesPriorProbability(active_variances_proposed)\n\n      pc = computeActiveVariancesPriorProbability(active_variances)\n\n    }\n\n\n    HR = sum(log(c(inactive_variances_proposed, active_variances_proposed)/c(inactive_variances, active_variances)))\n\n    if(tune) multi_sigma_trace[[1]][[1]] <<- c(multi_sigma_trace[[1]][[1]][-1],0)\n\n\n    Lp = (1 - spike_probability) * 1/(sqrt(inactive_variances_proposed) * sqrt2pi *\n                                        exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances_proposed)))\n\n    Lc = (1 - spike_probability) * 1/(sqrt(inactive_variances) * sqrt2pi *\n                                        exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances)))\n\n    if(!is.null(active_gene_set)){\n\n      actg_idx = which(gene_names[out_spike_idx] %in% active_gene_set)\n\n      Lp[actg_idx] = 0\n\n      Lc[actg_idx] = 0\n\n    }\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active[k] *\n          1/(sqrt(active_variances_proposed[k]) * sqrt2pi * exp((Yg[not_inspike] - active_means[k])^2/(2 * active_variances_proposed[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - active_means[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log((1 - weight_active) * Lp + weight_active * Lpk))\n    lnLc <- beta_oneLib * sum(log((1 - weight_active) * Lc + weight_active * Lck))\n\n    if(sigma_test) recover()\n\n    R = temperature * (lnLp + pp - lnLc - pc) + HR\n\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      # cat(\"*************MULTISIIIIIIGMAAAAAA!*********\", random_components, \"\\n\")\n\n      if(0 %in% random_components){\n\n        inactive_variances <<- inactive_variances_proposed\n\n        active_variances[pk] <<- active_variances_proposed[pk]\n\n      }else{\n\n        active_variances[pk1] <<- active_variances_proposed[pk1]\n\n        active_variances[pk2] <<- active_variances_proposed[pk2]\n\n      }\n\n      if(tune) multi_sigma_trace[[1]][[1]][100] <<- 1\n\n      .self$gibbsAllocationActiveInactive()\n      .self$gibbsAllocationWithinActive()\n\n\n    }\n\n  },\n\n  mhCombinedMultiMean = function(mean_test = FALSE, tune = FALSE){\n\n    # propose new component parameters\n    # propose/accept new allocations given the new parameters\n    # calculate R to accept/reject the new component params and new allocations\n\n    lib <- 1\n\n    active_means_dif_proposed <<- active_means_dif\n\n    inactive_means_proposed <<- inactive_means\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    # inspike <- which(inactive_spike_all == 1)\n\n\n    pk <- sample(seq(num_active_components), 1)\n\n    if(pk < num_active_components){\n\n      active_means_dif_proposed[c(pk, pk + 1)] <<- .self$twoMean_slide_move(active_means_dif[c(pk, pk + 1)], active_mean_tuningParam[pk])\n\n      if(tune) active_means_trace[[1]][[lib]][pk,] <<- c(active_means_trace[[1]][[lib]][pk,-1],0)\n\n    }else{\n\n      active_means_dif_proposed[pk] <<- abs(active_means_dif[pk] + rnorm(1,0,active_mean_tuningParam[pk]))\n\n      if(tune) active_means_trace[[1]][[lib]][pk,] <<- c(active_means_trace[[1]][[lib]][pk,-1],0)\n\n    }\n\n    pp = computeActiveMeansDifPriorProbability(active_means_dif_proposed)\n    pc = computeActiveMeansDifPriorProbability(active_means_dif)\n\n    Lp = (1 - weight_active) * (1 - spike_probability) *\n      1/(sqrt(inactive_variances) * sqrt2pi * exp((Yg[not_inspike] - inactive_means_proposed)^2/(2 * inactive_variances)))\n\n    Lc = (1 - weight_active) * (1 - spike_probability) *\n      1/(sqrt(inactive_variances) * sqrt2pi * exp((Yg[not_inspike] - inactive_means)^2/(2 * inactive_variances)))\n\n\n    if(!is.null(active_gene_set)){\n\n      actg_idx = which(gene_names[out_spike_idx] %in% active_gene_set)\n\n      Lp[actg_idx] = 0\n\n      Lc[actg_idx] = 0\n\n    }\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      mp = .self$calculate_active_means(active_means_dif_proposed)\n      mc = active_means\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - mp[k])^2/(2 * active_variances[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[not_inspike] - mc[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log(Lp + weight_active * Lpk))\n    lnLc <- beta_oneLib * sum(log(Lc + weight_active * Lck))\n\n    R = temperature * (lnLp + pp - lnLc - pc)\n\n    if(mean_test) recover()\n\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      # print(\"#______________________________ OLD _________________________________#\")\n\n      active_means_dif <<- active_means_dif_proposed\n\n      if(tune) active_means_trace[[1]][[lib]][pk,100] <<- 1\n\n      if(length(active_idx) > 0) active_means <<- mp\n\n      .self$gibbsAllocationActiveInactive()\n      .self$gibbsAllocationWithinActive()\n\n\n    }\n\n\n  },\n\n  mhSigmaSwap = function(ss_test = FALSE, tune = FALSE){\n\n    inactive_variances_proposed <<- inactive_variances\n\n    active_variances_proposed <<- active_variances\n\n    weight_within_active_proposed <<- weight_within_active\n\n    not_inspike <- which(inactive_spike_allocation == 0)\n\n    HR = 0\n\n    random_components = sample(1:num_active_components, 2, replace = FALSE)\n\n    pk1 <- random_components[1]\n\n    pk2 <- random_components[2]\n\n    weight_within_active_proposed[pk1] <<- weight_within_active[pk2]\n\n    weight_within_active_proposed[pk2] <<- weight_within_active[pk1]\n\n    active_variances_proposed[pk1] <<- active_variances[pk2]\n\n    active_variances_proposed[pk2] <<- active_variances[pk1]\n\n    pp = computeActiveVariancesPriorProbability(active_variances_proposed)\n\n    pc = computeActiveVariancesPriorProbability(active_variances)\n\n\n    Lpk = 0\n    Lck = 0\n\n    if(length(active_idx) > 0){\n\n      for(k in 1:num_active_components){\n\n        Lpk = Lpk + weight_within_active_proposed[k] *\n          1/(sqrt(active_variances_proposed[k]) * sqrt2pi * exp((Yg[active_idx] - active_means[k])^2/(2 * active_variances_proposed[k])))\n\n        Lck = Lck + weight_within_active[k] *\n          1/(sqrt(active_variances[k]) * sqrt2pi * exp((Yg[active_idx] - active_means[k])^2/(2 * active_variances[k])))\n\n      }\n\n    }\n\n    lnLp <- beta_oneLib * sum(log(Lpk))\n    lnLc <- beta_oneLib * sum(log(Lck))\n\n    R = temperature * (lnLp + pp - lnLc - pc) + HR\n\n    if(ss_test) recover()\n\n    if(log(runif(1)) < R & ! is.nan(R) & ! is.na(R)){\n\n      cat(\"************SWAAAAAPPPP!!!********\", active_means[random_components], \"\\n\")\n\n      weight_within_active <<- weight_within_active_proposed\n\n      active_variances[pk1] <<- active_variances_proposed[pk1]\n\n      active_variances[pk2] <<- active_variances_proposed[pk2]\n\n      .self$gibbsAllocationWithinActive()\n\n    }\n\n\n  }\n\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1562003872858.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "63|51|130|2|\n",
    "hash" : "2357587553",
    "id" : "F8D2AE1D",
    "lastKnownWriteTime" : 1562007275,
    "last_content_update" : 1562007284915,
    "path" : "C:/Users/ammon_work/Desktop/git_repos/normal_mixture/zigzag/R/zigzagProposals.R",
    "project_path" : "R/zigzagProposals.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}