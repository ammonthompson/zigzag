{
    "collab_server" : "",
    "contents" : "zigzag$methods(\n\n#' posteriorPredictiveSimulation\n#' @name posteriorPredictiveSimulation\n#'\n#' @param num_sims\n#' @param plotlib\n#' @param prefix\n#' @param recover_x\n#'\n#' @return\n#' @export\n#'\n#' @examples\n  posteriorPredictiveSimulation = function(num_sims = 1000, plotlib = 1, prefix = \"out\", recover_x = FALSE){\n\n   pp_prefix = paste0(output_directory, \"/\", prefix, \"_mcmc_output/\", prefix)\n\n   ##################\n   ### FUNCTIONS ####\n   ##################\n\n   #function pars\n   binwidth = 0.1\n   model_range = c(qnorm(0.000001, inactive_means, sqrt(inactive_variances)),\n                   qnorm(0.999999, active_means[num_active_components], sqrt(active_variances[num_active_components])))\n   Yg_range = c(min(Yg[out_spike_idx]), max(Yg[out_spike_idx]))\n   xg_greater_minusInf_idx = which(Xg > -Inf, arr.ind = T)\n   Xg_range = c(min(Xg[xg_greater_minusInf_idx]), max(Xg[xg_greater_minusInf_idx]))\n   all_ranges = c(model_range, Yg_range, Xg_range)\n\n   bins = seq(min(all_ranges) - 2, max(all_ranges) + 2, by = binwidth)\n\n   yg_lessThan_bin = sapply(bins, function(y) (Yg < y) * 1 )\n\n   get_cumulative = function(xdat){ #xdat is a vector (one library)\n\n     zeroIdx = which(xdat == -Inf)\n\n     num_zeros = length(zeroIdx)\n\n     p_zeros = num_zeros/num_transcripts\n\n     xdat = xdat[-zeroIdx]\n\n     F = c()\n\n     for( x in bins ) F = c( F, count( xdat <= x )/(num_transcripts - num_zeros))\n\n     return( c(p_zeros, F) )\n\n   }\n\n   get_rumsfeld = function(xdat, rec_x = FALSE){\n\n     model_Br = sapply(seq(num_libraries), function(r) (1 - spike_probability * (1 - weight_active)) * mean(1 - p_x[out_spike_idx, r]) +\n                         spike_probability * (1 - weight_active))\n\n     xdat_Br = sapply(seq(num_libraries), function(r) sum(xdat[,r] == -Inf)/num_transcripts)\n\n     if(rec_x == T) recover()\n\n     return(mean(abs(xdat_Br - model_Br)))\n\n   }\n\n   get_level1_wasserstein = function(xdat, rec_x = FALSE){\n\n     model_cum = sapply(seq(num_libraries), function(r){\n       colMeans(p_x[out_spike_idx, r] * yg_lessThan_bin[out_spike_idx, ])\n     })\n\n\n     norm_factor = colMaxs(model_cum)\n\n     model_cum = t(t(model_cum)/norm_factor)\n\n     xdat_cum = sapply(seq(num_libraries), function(r){\n       sapply(bins, function(y) mean(xdat[xdat[,r] > -Inf, r] < y))\n     })\n\n     #average number of genes detected < x averaged over all libraries and the wasserstein distance.\n     mean_xdat_cum = rowMeans(xdat_cum)\n     mean_model_cum = rowMeans(model_cum)\n     Wass_means = trapz_integration(bins, abs(mean_xdat_cum - mean_model_cum))\n\n     if(rec_x == T) recover()\n\n     return(c(Wass_means))\n\n   }\n\n   get_level2_wasserstein = function(ydat, rec_x = FALSE){\n\n     model_cum = get_model_cumulative(bins)\n\n     ydat_cum = sapply(bins[-1], function(x) mean(ydat[out_spike_idx] < x))\n\n     Wass_means = trapz_integration(bins[-1], abs(ydat_cum - model_cum))\n\n     if(rec_x == T) recover()\n\n     return(Wass_means)\n\n   }\n\n\n   #####################\n   ### END FUNCTIONS ###\n   #####################\n\n\n   #### Simulate data from posterior and compute realized discrepancy statstics\n\n   sim_xg = sapply(1:num_libraries, function(x){return(rnorm(length(Yg), Yg, sqrt(sigma_g)))})\n\n   # p detect\n   sim_xg = sapply(1:num_libraries, function(lib){\n\n     temp_sim_xg = sim_xg[,lib]\n\n     not_detected = (runif(length(Yg)) < (1 - p_x[,lib]))\n\n     temp_sim_xg[not_detected] <- -Inf\n\n     return(temp_sim_xg)\n\n   })\n\n   ### simulate spike p( spike | inactive )\n   sim_xg[in_spike_idx,] = rep(-Inf, num_libraries)\n\n   sim_xg = as.data.frame(sim_xg)\n\n   # level 1 discrepencies, zeros and non-zero Xg distros\n   W_L1 = get_level1_wasserstein(Xg) - get_level1_wasserstein(sim_xg)\n   B_rumsfeld = get_rumsfeld(Xg) - get_rumsfeld(sim_xg)\n\n\n   ### level 2 discrepency simulating Yg\n   #simulate Yg\n   sim_yg = NULL\n   sim_yg[inactive_idx] = rnorm(length(inactive_idx), inactive_means, sqrt(inactive_variances))\n   sim_yg[active_idx] = rnorm(length(active_idx), active_means[allocation_within_active[[1]][active_idx]],\n                              sqrt(active_variances[allocation_within_active[[1]][active_idx]]))\n\n\n   W_L2 = get_level2_wasserstein(Yg) - get_level2_wasserstein(sim_yg)\n\n   cat(\"W_L1: \",W_L1, \"  W_L2: \", W_L2, '\\n')\n\n   if(recover_x) recover()\n\n   write.table(matrix(c(gen, W_L1, W_L2, B_rumsfeld), nrow = 1),\n               file = paste0(pp_prefix, \".post_predictive_output.log\"),\n               append=T, sep=\"\\t\", row.names=F, col.names=F)\n\n   return(list(sim_xg, sim_yg))\n\n  }\n\n\n)\n",
    "created" : 1562179082453.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "14|108|159|2|\n",
    "hash" : "2449749506",
    "id" : "D23C586A",
    "lastKnownWriteTime" : 1562179220,
    "last_content_update" : 1562179542436,
    "path" : "C:/Users/ammon_work/Desktop/git_repos/normal_mixture/zigzag/R/zigzagPostpred.R",
    "project_path" : "R/zigzagPostpred.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}