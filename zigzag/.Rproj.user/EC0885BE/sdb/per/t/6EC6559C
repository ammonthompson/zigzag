{
    "collab_server" : "",
    "contents" : "zigzag$methods(\n\n  ###############\n  # Constructor #\n  ###############\n\n  initialize = function(data, gene_length = NULL, candidate_gene_list = \"random\",\n                        num_active_components = 1,\n                        weight_active_shape_1 = 2,\n                        weight_active_shape_2 = 2,\n                        inactive_means_prior_shape = 1,\n                        inactive_means_prior_rate = 1/3,\n                        inactive_variances_prior_min = 0.01,\n                        inactive_variances_prior_max = 5,\n                        spike_prior_shape_1 = 1,\n                        spike_prior_shape_2 = 1,\n                        active_means_dif_prior_shape = 1,\n                        active_means_dif_prior_rate = 1/3,\n                        active_variances_prior_min = 0.01,\n                        active_variances_prior_max = 5,\n                        shared_active_variances = TRUE,\n                        output_directory = \"output\",\n                        multi_ta = FALSE,\n                        threshold_a = 0,\n                        threshold_i = threshold_a[1],\n                        beta = 1,\n                        temperature = 1,\n                        tau_shape = 1,\n                        tau_rate = 1,\n                        s0_mu = -1,\n                        s0_sigma = 2,\n                        s1_shape = 1,\n                        s1_rate = 2,\n                        alpha_r_shape = 1,\n                        alpha_r_rate = 1/10,\n                        active_gene_set = NULL,\n\n                        ...) {\n\n    ##########################################\n    ## Set up data and general data params  ##\n    ##########################################\n\n    cat(\"Loading and log-transforming data...\\n\")\n\n    sqrt2pi         <<- sqrt(2*pi)\n    inf_tol         <<- -Inf\n    temperature     <<- temperature\n    beta            <<- beta\n    beta_oneLib     <<- 1\n    gen             <<- 0\n    gene_names      <<- rownames(data)\n    num_libraries   <<- ncol(data)\n    num_transcripts <<- nrow(data)\n\n    # Active sub-components\n    num_active_components <<- as.integer(num_active_components)\n    component_matrix      <<- matrix(rep(c(0,seq(num_active_components)), num_transcripts),\n                                ncol=num_active_components+1, byrow = T)\n\n\n    #Set up Xg\n    if(min(data) >= 0) Xg <<- log(as.matrix(data)) else Xg <<- as.matrix(data)\n    Xg[Xg == -Inf] <<- inf_tol\n\n\n    # Gene lengths, scaled to have mean = 1\n    if(! is.null(gene_length)){\n\n      if( is.vector(gene_length) ) gene_lengths <<- gene_length/mean(gene_length) else gene_lengths <<- gene_length[,1]/mean(gene_length[,1])\n\n    }else{\n\n      gene_lengths <<- rep(1, num_transcripts)\n\n    }\n\n    if(length(gene_lengths) != num_transcripts) cat(\"WARNING: genelengths size does not equal number of genes!!!\\n\")\n\n\n    # candidate genes to output posterior samples to files\n    if(candidate_gene_list[1] == \"random\"){\n\n      candidate_gene_list <<- c(gene_names[c(1:10,sample(num_transcripts, size = 100, replace = F))])\n\n    }else{\n\n      candidate_gene_list <<- candidate_gene_list\n\n      if(length(which(!( candidate_gene_list %in% gene_names))) > 0){\n        print(\"WARNING: one or more gene list names are not in the data\")\n        print(candidate_gene_list[which(!( candidate_gene_list %in% gene_names))])\n      }\n\n    }\n\n    # Set up active genes: the genes user is certain are actively expressed. Default is NULL\n    if(!is.null(active_gene_set)){\n\n      active_gene_set     <<- active_gene_set\n      active_gene_set_idx <<- sapply(seq(active_gene_set), function(gene) which(gene_names == active_gene_set[gene]) )\n\n    }\n\n    # create output directory\n    output_directory <<- output_directory\n    dir.create(output_directory)\n\n\n    ##########################################################\n    ### initialize proposal tuning parameters \"tuningParam\" ##\n    ##########################################################\n\n    inactive_mean_tuningParam <<- 0.5\n    inactive_variance_tuningParam <<- 0.5\n    spike_probability_tuningParam <<- 1000\n    active_mean_tuningParam <<- rep(0.5, num_active_components)\n    active_variance_tuningParam <<- rep(0.5, num_active_components)\n    mixture_weight_tuningParam <<- 1000\n    tuningParam_s0     <<- 0.05\n    tuningParam_s1     <<- 0.05\n    tuningParam_tau    <<- 0.05\n    tuningParam_s0tau <<- 0.05\n    tuningParam_alpha_r <<- rep(0.5, num_libraries)\n    tuningParam_yg <<- rep(0.5, num_transcripts)\n    tuningParam_sigma_g <<- rep(0.5, num_transcripts)\n    tuningParam_multi_sigma <<- 0.5\n    tuningParam_sigma_mu <<- 0.5\n\n\n    ########################################################\n    ## Set thresholds for component mean priors ############\n    ########################################################\n    multi_thresh_a <<- multi_ta\n\n    if(length(threshold_a) == num_active_components){\n\n      multi_thresh_a <<- TRUE\n      threshold_a <<- threshold_a\n\n    }else{\n\n      threshold_a <<- threshold_a[1]\n\n    }\n\n    threshold_i <<- threshold_i\n\n    #############################################################\n    ## Set up parameter proposal relative probabilities #########\n    #############################################################\n    proposal_probs <<- c(10, 10, 10,                                    ### weights, alloc active_inactive, alloc within_active\n                          10, 10,                                         ### i_mean, i_var\n                          8 * num_active_components,                    ### a_mean\n                          8 + 8 * (num_active_components - 1) * (1 - shared_active_variances),            ### a_var\n                          5, 5,                                         ### spike prob, spike alloc\n                          c(1, 1) * 1,           ### Yg, sigm_g\n                          8, 8, 3,                                    ### tau, Sg, s0tau\n                          num_libraries * 0.75)                         ### p_x\n\n\n    ##########################\n    # Initialize the priors. #\n    # Level 2 (upper) priors #\n    ##########################\n\n    cat(\"Initializing upper level parameters...\\n\")\n\n    # active vs inactive\n    weight_active_shape_1 <<- weight_active_shape_1\n    weight_active_shape_2 <<- weight_active_shape_2\n    weight_active <<- rbeta(1, weight_active_shape_1 + 1, weight_active_shape_2 + 1)\n    weight_active_proposed <<- weight_active\n\n    weight_active_prob <<- .self$computeActiveWeightPriorProbability(weight_active)\n    weight_active_prob_proposed <<- .self$computeActiveWeightPriorProbability(weight_active_proposed)\n\n    # inactive means\n    inactive_means_prior_shape <<- inactive_means_prior_shape\n    inactive_means_prior_rate  <<- inactive_means_prior_rate\n    inactive_means <<- threshold_i - rgamma(1, shape = 1, rate = 1)\n\n    inactive_means_proposed <<- inactive_means\n    inactive_means_prob <<- .self$computeInactiveMeansPriorProbability(inactive_means)\n    inactive_means_prob_proposed <<- .self$computeInactiveMeansPriorProbability(inactive_means_proposed)\n    inactive_means_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n\n    # inactive variances\n    inactive_variances_prior_min <<- inactive_variances_prior_min\n    inactive_variances_prior_max <<- inactive_variances_prior_max\n    inactive_variances_prior_log_min <<- log(inactive_variances_prior_min, 10)\n    inactive_variances_prior_log_max <<- log(inactive_variances_prior_max, 10)\n    inactive_variances <<- 10^(runif(1, inactive_variances_prior_log_min, inactive_variances_prior_log_max))\n    inactive_variances_proposed <<- inactive_variances\n    inactive_variances_prob <<- .self$computeInactiveVariancesPriorProbability(inactive_variances)\n    inactive_variances_prob_proposed <<- .self$computeInactiveVariancesPriorProbability(inactive_variances_proposed)\n    inactive_variances_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n\n    # spike priors\n    spike_prior_shape_1 <<- spike_prior_shape_1\n    spike_prior_shape_2 <<- spike_prior_shape_2\n    spike_probability <<- rbeta(1, spike_prior_shape_1, spike_prior_shape_2)\n    spike_probability_proposed <<- spike_probability\n    spike_probability_prob <<- .self$computeSpikePriorProbability(spike_probability)\n    spike_probability_prob_proposed <<- .self$computeSpikePriorProbability(spike_probability_proposed)\n    spike_probability_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n\n    # active means\n    active_means_dif_prior_shape <<- active_means_dif_prior_shape\n    active_means_dif_prior_rate  <<- active_means_dif_prior_rate\n    active_means_dif <<- rgamma(num_active_components, shape = active_means_dif_prior_rate, rate = active_means_dif_prior_rate)\n\n    active_means_dif_proposed <<- active_means_dif\n    active_means_dif_prob <<- .self$computeActiveMeansDifPriorProbability(active_means_dif)\n    active_means_dif_prob_proposed <<- .self$computeActiveMeansDifPriorProbability(active_means_dif_proposed)\n    active_means_trace[[1]] <<- lapply(1,function(x){return(t(sapply(1:num_active_components,function(y){return(c(rep(0,77),rep(1,23)))})))})\n    active_means <<- .self$calculate_active_means(active_means_dif, mt = multi_thresh_a)\n\n    # active variances\n    active_variances_prior_min <<- active_variances_prior_min\n    active_variances_prior_max <<- active_variances_prior_max\n    active_variances_prior_log_min <<- log(active_variances_prior_min, 10)\n    active_variances_prior_log_max <<- log(active_variances_prior_max, 10)\n\n    shared_active_variances <<- shared_active_variances\n    if(shared_active_variances){\n\n      active_variances <<- rep(10^(runif(1, active_variances_prior_log_min, active_variances_prior_log_max)), num_active_components)\n      active_variances_proposed <<- active_variances\n      active_variances_prob <<- .self$computeActiveVariancesPriorProbability(active_variances[1])\n      active_variances_prob_proposed <<- .self$computeActiveVariancesPriorProbability(active_variances_proposed)\n      active_variances_trace[[1]] <<- lapply(1,function(x){return(t(sapply(1:num_active_components,function(y){return(c(rep(0,77),rep(1,23)))})))})\n\n    }else{\n\n      active_variances <<- 10^(runif(num_active_components, active_variances_prior_log_min, active_variances_prior_log_max))\n      active_variances_proposed <<- active_variances\n      active_variances_prob <<- .self$computeActiveVariancesPriorProbability(active_variances)\n      active_variances_prob_proposed <<- .self$computeActiveVariancesPriorProbability(active_variances_proposed)\n      active_variances_trace[[1]] <<- lapply(1,function(x){return(t(sapply(1:num_active_components,function(y){return(c(rep(0,77),rep(1,23)))})))})\n\n    }\n\n    weight_within_active_alpha <<- rep(weight_active_shape_1/num_active_components, num_active_components)\n\n    weight_within_active <<- .self$r_dirichlet(.self$weight_within_active_alpha)\n    weight_within_active_proposed <<- weight_within_active\n    weight_within_active_prob <<- .self$computeWithinActiveWeightPriorProbability(weight_within_active)\n    weight_within_active_prob_proposed <<- .self$computeWithinActiveWeightPriorProbability(weight_within_active_proposed)\n    mixture_weight_trace[[1]] <<- list(c(rep(0,77),rep(1,23)))\n\n    # initialize the allocations\n    allocation_active_inactive <<- rbinom(num_transcripts, size=1, p=weight_active)\n    if(!is.null(active_gene_set)) allocation_active_inactive[active_gene_set_idx] <<- as.integer(1)\n    allocation_active_inactive_proposed <<- allocation_active_inactive\n\n    allocation_within_active[[1]] <<- sample.int(num_active_components, size=num_transcripts, replace=TRUE, prob=weight_within_active)\n    allocation_within_active_proposed <<- allocation_within_active\n\n    all_allocation = allocation_active_inactive * allocation_within_active[[1]]\n\n    allocation_trace <<- matrix(apply(component_matrix, 2, function(comp_matrix_col) 1 *\n                                           (comp_matrix_col == all_allocation)), nrow = num_transcripts)\n\n    # combined move parameters\n    multi_sigma_trace[[1]] <<- list(c(rep(0,77),rep(1,23)))\n    sigma_mu_trace[[1]] <<- list(c(rep(0,77),rep(1,23)))\n\n\n    ##########################\n    # level 1 (lower) priors #\n    ##########################\n\n    cat(\"Initializing lower level parameters...\\n\")\n\n    # gene detection prob\n    alpha_r_shape <<- alpha_r_shape\n    alpha_r_rate <<- alpha_r_rate\n    alpha_r <<- rgamma(num_libraries, 1, 1)\n    alpha_r_trace[[1]] <<- lapply(1,function(x){return(t(sapply(1:num_libraries,function(y){return(c(rep(0,77),rep(1,23)))})))})\n    alpha_r_max = max(alpha_r)\n\n    # gene-wise variance\n    s0_mu <<- s0_mu\n    s0_sigma <<- s0_sigma\n    s1_rate <<- s1_rate\n    s1_shape <<- s1_shape\n    tau_shape <<- tau_shape\n    tau_rate <<- tau_rate\n\n    s0 <<- rnorm(1, s0_mu, s0_sigma)\n    s1 <<- -rgamma(1, s1_shape, s1_rate)\n    tau <<- rgamma(1, tau_shape, tau_rate)\n\n    s0_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n    s1_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n    tau_trace[[1]] <<- lapply(1,function(x){return(c(rep(0,77),rep(1,23)))})\n    s0tau_trace[[1]] <<- lapply(1, function(x){return(c(rep(0,77), rep(1,23)))})\n\n    ## Yg initialize\n    no_detect_spike <<- ((rowSums(as.matrix((Xg[seq(num_transcripts),, drop = F] ==\n                                                     rep(-Inf, num_libraries)) * 1)) == num_libraries) * 1)\n    inactive_spike_allocation <<- no_detect_spike\n    in_spike_idx <<- which(no_detect_spike == 1)\n    out_spike_idx <<- which(no_detect_spike == 0)\n    all_zero_idx <<- which(no_detect_spike == 1)\n    allocation_active_inactive[in_spike_idx] <<- as.integer(0)\n    active_idx <<- which(allocation_active_inactive == 1)\n    inactive_idx <<- which(allocation_active_inactive == 0)\n\n\n    # initialize Yg and sigma_g near observed values in data. If undetected, sample\n    if(num_libraries > 1 & max(Xg) > -Inf){\n\n      #Yg from Xg means\n      rwm <- sapply(seq(num_transcripts), function(x){\n        if(count(Xg[x,], value = -Inf) < num_libraries){\n          v = Xg[x,]\n          mean(v[v > -Inf])\n        }else{\n          rnorm(1, inactive_means, sqrt(inactive_variances))\n        }\n      })\n\n      #Yg from Xg variances\n      rwv <- sapply(seq(num_transcripts), function(x){\n        if(count(Xg[x,], value = -Inf) < (num_libraries - 1)){\n          v = Xg[x,]\n          var(v[v > -Inf])\n        }else{\n          rlnorm(1, log(mean(rowVars(Xg), na.rm = T)), sqrt(var(rowVars(Xg), na.rm = T)))\n        }\n      })\n\n      Yg <<- rnorm(num_transcripts, rwm, sqrt(rwv))\n\n    }else{\n\n      Yg <<- Xg[,1]\n\n      Yg[which(Yg == inf_tol)] <<- rnorm(length(which(Yg == inf_tol)), inactive_means, sqrt(inactive_variances))\n\n    }\n\n    Yg_proposed <<- Yg\n\n    Yg_trace <<- t(sapply(seq(num_transcripts), function(g){return(c(rep(0,77),rep(1,23)))}))\n\n\n    ## Initialize Sigma_x and Sigma_g gene variance and shrinkage prior parameters\n    Sg <<- exp(s0 + s1 * Yg)\n    sigma_g <<- rlnorm(num_transcripts, 2, 1/2)\n    sigma_g_trace <<- t(sapply(seq(num_transcripts), function(g){return(c(rep(0,77),rep(1,23)))}))\n\n    p_x <<- .self$get_px()\n\n    # Initialize XgLikelihood. resample Yg and downstream values if -Inf likelihood results\n    XgLikelihood <<- .self$computeXgLikelihood(Xg, Yg, sigma_g, p_x)\n\n    cat(\"Reinitialize genes with zero likelihood: \", which(XgLikelihood == -Inf), \"\\n\")\n\n    # Occasionally there are combinations of intial values of Yg and alpha_r\n    # that can lead to 0 likelihood for some genes.\n    # For those genes, reinitialize until a combination that has > 0 likelihood is generated.\n    if(num_libraries > 1){\n\n      counter = 0\n\n      while(count(XgLikelihood, value = -Inf) > 0){\n\n        Yg[which(XgLikelihood == -Inf)] <<- rnorm(length(which(XgLikelihood == -Inf)), inactive_means, sqrt(inactive_variances))\n\n        Sg <<- exp(s0 + s1 * Yg)\n\n        p_x <<- .self$get_px()\n\n        sigma_g <<- rlnorm(num_transcripts, log(Sg) + tau/10, sqrt(tau/10))\n\n        XgLikelihood <<- .self$computeXgLikelihood(Xg, Yg, sigma_g, p_x)\n\n        counter  = counter + 1\n\n        if(counter > 1000){\n          cat(\"initialization failed. Try again\\n\")\n          break\n        }\n\n      }\n\n    }\n\n    sigma_g_probability <<- .self$computeSigmaGPriorProbability(sigma_g, Sg)\n\n    ## write user specified prior parameter values to file\n    write.table(data.frame(cbind(c(\"s0_mu\", \"s0_sigma\", \"s1_shape\", \"s1_rate\", \"tau_rate\", \"tau_shape\", \"alpha_r_shape\", \"alpha_r_rate\",\n               \"weight_active_shape_1\", \"weight_active_shape_2\", \"weight_within_active_alpha\", \"spike_prior_shape_1\", \"spike_prior_shape_2\",\n               \"active_means_dif_prior_shape\", \"active_meaans_dif_prior_rate\", \"active_variances_prior_min\", \"active_variances_prior_max\",\n               \"inactive_means_prior_shape\", \"inactive_means_prior_rate\", \"inactive_variances_prior_min\", \"inactive_variances_prior_max\", \"threshold_i\", \"threshold_a\"),\n              c(s0_mu, s0_sigma, s1_shape, s1_rate, tau_rate, tau_shape,  alpha_r_shape, alpha_r_rate,\n               weight_active_shape_1, weight_active_shape_2, weight_within_active_alpha[1], spike_prior_shape_1, spike_prior_shape_2,\n               active_means_dif_prior_shape, active_means_dif_prior_rate , active_variances_prior_min, active_variances_prior_max,\n               inactive_means_prior_shape, inactive_means_prior_rate, inactive_variances_prior_min, inactive_variances_prior_max,threshold_i,\n               paste(threshold_a, collapse=\", \")))),\n              file = paste0(output_directory, \"/\", \"hyperparameter_settings.txt\"), sep = \"\\t\", row.names = F, quote = F, col.names = F)\n\n\n    ###### YgLikelihood is not used ???? delete?\n    YgLikelihood[inactive_idx] <<- .self$computeInactiveLikelihood(y = Yg[inactive_idx], spike_p = spike_probability, im = inactive_means, iv = inactive_variances, spike_allocation = inactive_spike_allocation[inactive_idx])\n    YgLikelihood[active_idx] <<- .self$computeActiveLikelihood(y = Yg[active_idx], active_component = allocation_within_active[[1]][active_idx], am = active_means, av = active_variances)\n\n\n    #######################\n    #####Book keeping######\n    #######################\n\n    field_list_values <<- list(allocation_active_inactive, allocation_within_active, inactive_spike_allocation,\n                        weight_active, weight_within_active,\n                        inactive_means, inactive_variances, active_means, active_means_dif, active_variances,\n                        Xg, Yg, s0, s1, Sg, sigma_g, alpha_r, p_x,\n                        active_idx, inactive_idx, in_spike_idx, out_spike_idx)\n\n    field_list_names <<- list(\"allocation_active_inactive\", \"allocation_within_active\", \"inactive_spike_allocation\",\n                        \"weight_active\", \"weight_within_active\",\n                        \"inactive_means\", \"inactive_variances\", \"active_means\", \"active_means_dif\", \"active_variances\",\n                        \"Xg\", \"Yg\", \"s0\", \"s1\", \"Sg\", \"sigma_g\", \"alpha_r\", \"p_x\",\n                        \"active_idx\", \"inactive_idx\", \"in_spike_idx\", \"out_spike_idx\")\n\n\n    lnl_trace[[1]] <<- sum(XgLikelihood)\n\n\n  }\n\n)\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1561585155950.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2918704326",
    "id" : "6EC6559C",
    "lastKnownWriteTime" : 1562714841,
    "last_content_update" : 1562714841446,
    "path" : "C:/Users/ammon_work/Desktop/git_repos/normal_mixture/zigzag/R/zigzagInitialize.R",
    "project_path" : "R/zigzagInitialize.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}